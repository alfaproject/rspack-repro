"use strict";
exports.id = "vendors-node_modules_aws-crypto_crc32_build_aws_crc32_js-node_modules_aws-crypto_crc32_build_-597852";
exports.ids = ["vendors-node_modules_aws-crypto_crc32_build_aws_crc32_js-node_modules_aws-crypto_crc32_build_-597852"];
exports.modules = {

/***/ "./node_modules/@aws-crypto/crc32/build/aws_crc32.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AwsCrc32 = void 0;
var tslib_1 = __webpack_require__("./node_modules/@aws-crypto/crc32/node_modules/tslib/tslib.es6.js");
var util_1 = __webpack_require__("./node_modules/@aws-crypto/util/build/index.js");
var index_1 = __webpack_require__("./node_modules/@aws-crypto/crc32/build/index.js");
var AwsCrc32 = /** @class */ (function () {
    function AwsCrc32() {
        this.crc32 = new index_1.Crc32();
    }
    AwsCrc32.prototype.update = function (toHash) {
        if ((0, util_1.isEmptyData)(toHash))
            return;
        this.crc32.update((0, util_1.convertToBuffer)(toHash));
    };
    AwsCrc32.prototype.digest = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, (0, util_1.numToUint8)(this.crc32.digest())];
            });
        });
    };
    AwsCrc32.prototype.reset = function () {
        this.crc32 = new index_1.Crc32();
    };
    return AwsCrc32;
}());
exports.AwsCrc32 = AwsCrc32;
//# sourceMappingURL=aws_crc32.js.map

/***/ }),

/***/ "./node_modules/@aws-crypto/crc32/build/index.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AwsCrc32 = exports.Crc32 = exports.crc32 = void 0;
var tslib_1 = __webpack_require__("./node_modules/@aws-crypto/crc32/node_modules/tslib/tslib.es6.js");
var util_1 = __webpack_require__("./node_modules/@aws-crypto/util/build/index.js");
function crc32(data) {
    return new Crc32().update(data).digest();
}
exports.crc32 = crc32;
var Crc32 = /** @class */ (function () {
    function Crc32() {
        this.checksum = 0xffffffff;
    }
    Crc32.prototype.update = function (data) {
        var e_1, _a;
        try {
            for (var data_1 = tslib_1.__values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
                var byte = data_1_1.value;
                this.checksum =
                    (this.checksum >>> 8) ^ lookupTable[(this.checksum ^ byte) & 0xff];
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (data_1_1 && !data_1_1.done && (_a = data_1.return)) _a.call(data_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return this;
    };
    Crc32.prototype.digest = function () {
        return (this.checksum ^ 0xffffffff) >>> 0;
    };
    return Crc32;
}());
exports.Crc32 = Crc32;
// prettier-ignore
var a_lookUpTable = [
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA,
    0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
    0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,
    0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,
    0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC,
    0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,
    0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
    0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940,
    0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116,
    0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
    0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
    0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A,
    0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818,
    0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
    0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,
    0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C,
    0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,
    0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,
    0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
    0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086,
    0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4,
    0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,
    0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,
    0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,
    0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE,
    0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,
    0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
    0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252,
    0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60,
    0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,
    0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,
    0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04,
    0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A,
    0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
    0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,
    0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E,
    0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,
    0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
    0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,
    0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0,
    0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6,
    0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,
    0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D,
];
var lookupTable = (0, util_1.uint32ArrayFrom)(a_lookUpTable);
var aws_crc32_1 = __webpack_require__("./node_modules/@aws-crypto/crc32/build/aws_crc32.js");
Object.defineProperty(exports, "AwsCrc32", ({ enumerable: true, get: function () { return aws_crc32_1.AwsCrc32; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@aws-crypto/crc32/node_modules/tslib/tslib.es6.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   __assign: () => (/* binding */ __assign),
/* harmony export */   __asyncDelegator: () => (/* binding */ __asyncDelegator),
/* harmony export */   __asyncGenerator: () => (/* binding */ __asyncGenerator),
/* harmony export */   __asyncValues: () => (/* binding */ __asyncValues),
/* harmony export */   __await: () => (/* binding */ __await),
/* harmony export */   __awaiter: () => (/* binding */ __awaiter),
/* harmony export */   __classPrivateFieldGet: () => (/* binding */ __classPrivateFieldGet),
/* harmony export */   __classPrivateFieldSet: () => (/* binding */ __classPrivateFieldSet),
/* harmony export */   __createBinding: () => (/* binding */ __createBinding),
/* harmony export */   __decorate: () => (/* binding */ __decorate),
/* harmony export */   __exportStar: () => (/* binding */ __exportStar),
/* harmony export */   __extends: () => (/* binding */ __extends),
/* harmony export */   __generator: () => (/* binding */ __generator),
/* harmony export */   __importDefault: () => (/* binding */ __importDefault),
/* harmony export */   __importStar: () => (/* binding */ __importStar),
/* harmony export */   __makeTemplateObject: () => (/* binding */ __makeTemplateObject),
/* harmony export */   __metadata: () => (/* binding */ __metadata),
/* harmony export */   __param: () => (/* binding */ __param),
/* harmony export */   __read: () => (/* binding */ __read),
/* harmony export */   __rest: () => (/* binding */ __rest),
/* harmony export */   __spread: () => (/* binding */ __spread),
/* harmony export */   __spreadArrays: () => (/* binding */ __spreadArrays),
/* harmony export */   __values: () => (/* binding */ __values)
/* harmony export */ });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __createBinding(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}

function __exportStar(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
}


/***/ }),

/***/ "./node_modules/@aws-crypto/util/build/convertToBuffer.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.convertToBuffer = void 0;
var util_utf8_browser_1 = __webpack_require__("./node_modules/@aws-sdk/util-utf8-browser/dist-es/index.js");
// Quick polyfill
var fromUtf8 = typeof Buffer !== "undefined" && Buffer.from
    ? function (input) { return Buffer.from(input, "utf8"); }
    : util_utf8_browser_1.fromUtf8;
function convertToBuffer(data) {
    // Already a Uint8, do nothing
    if (data instanceof Uint8Array)
        return data;
    if (typeof data === "string") {
        return fromUtf8(data);
    }
    if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    }
    return new Uint8Array(data);
}
exports.convertToBuffer = convertToBuffer;
//# sourceMappingURL=convertToBuffer.js.map

/***/ }),

/***/ "./node_modules/@aws-crypto/util/build/index.js":
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uint32ArrayFrom = exports.numToUint8 = exports.isEmptyData = exports.convertToBuffer = void 0;
var convertToBuffer_1 = __webpack_require__("./node_modules/@aws-crypto/util/build/convertToBuffer.js");
Object.defineProperty(exports, "convertToBuffer", ({ enumerable: true, get: function () { return convertToBuffer_1.convertToBuffer; } }));
var isEmptyData_1 = __webpack_require__("./node_modules/@aws-crypto/util/build/isEmptyData.js");
Object.defineProperty(exports, "isEmptyData", ({ enumerable: true, get: function () { return isEmptyData_1.isEmptyData; } }));
var numToUint8_1 = __webpack_require__("./node_modules/@aws-crypto/util/build/numToUint8.js");
Object.defineProperty(exports, "numToUint8", ({ enumerable: true, get: function () { return numToUint8_1.numToUint8; } }));
var uint32ArrayFrom_1 = __webpack_require__("./node_modules/@aws-crypto/util/build/uint32ArrayFrom.js");
Object.defineProperty(exports, "uint32ArrayFrom", ({ enumerable: true, get: function () { return uint32ArrayFrom_1.uint32ArrayFrom; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@aws-crypto/util/build/isEmptyData.js":
/***/ ((__unused_webpack_module, exports) => {


// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isEmptyData = void 0;
function isEmptyData(data) {
    if (typeof data === "string") {
        return data.length === 0;
    }
    return data.byteLength === 0;
}
exports.isEmptyData = isEmptyData;
//# sourceMappingURL=isEmptyData.js.map

/***/ }),

/***/ "./node_modules/@aws-crypto/util/build/numToUint8.js":
/***/ ((__unused_webpack_module, exports) => {


// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.numToUint8 = void 0;
function numToUint8(num) {
    return new Uint8Array([
        (num & 0xff000000) >> 24,
        (num & 0x00ff0000) >> 16,
        (num & 0x0000ff00) >> 8,
        num & 0x000000ff,
    ]);
}
exports.numToUint8 = numToUint8;
//# sourceMappingURL=numToUint8.js.map

/***/ }),

/***/ "./node_modules/@aws-crypto/util/build/uint32ArrayFrom.js":
/***/ ((__unused_webpack_module, exports) => {


// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uint32ArrayFrom = void 0;
// IE 11 does not support Array.from, so we do it manually
function uint32ArrayFrom(a_lookUpTable) {
    if (!Uint32Array.from) {
        var return_array = new Uint32Array(a_lookUpTable.length);
        var a_index = 0;
        while (a_index < a_lookUpTable.length) {
            return_array[a_index] = a_lookUpTable[a_index];
            a_index += 1;
        }
        return return_array;
    }
    return Uint32Array.from(a_lookUpTable);
}
exports.uint32ArrayFrom = uint32ArrayFrom;
//# sourceMappingURL=uint32ArrayFrom.js.map

/***/ }),

/***/ "./node_modules/@aws-sdk/client-cloudwatch/dist-es/CloudWatchClient.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  CloudWatchClient: () => (/* binding */ CloudWatchClient)
});

// UNUSED EXPORTS: __Client

// EXTERNAL MODULE: ./node_modules/@aws-sdk/middleware-host-header/dist-es/index.js
var dist_es = __webpack_require__("./node_modules/@aws-sdk/middleware-host-header/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/@aws-sdk/middleware-logger/dist-es/index.js + 1 modules
var middleware_logger_dist_es = __webpack_require__("./node_modules/@aws-sdk/middleware-logger/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/@aws-sdk/middleware-recursion-detection/dist-es/index.js
var middleware_recursion_detection_dist_es = __webpack_require__("./node_modules/@aws-sdk/middleware-recursion-detection/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/@aws-sdk/middleware-signing/dist-es/index.js + 5 modules
var middleware_signing_dist_es = __webpack_require__("./node_modules/@aws-sdk/middleware-signing/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/@aws-sdk/middleware-user-agent/dist-es/index.js + 13 modules
var middleware_user_agent_dist_es = __webpack_require__("./node_modules/@aws-sdk/middleware-user-agent/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/@smithy/config-resolver/dist-es/index.js + 13 modules
var config_resolver_dist_es = __webpack_require__("./node_modules/@smithy/config-resolver/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/@smithy/middleware-content-length/dist-es/index.js
var middleware_content_length_dist_es = __webpack_require__("./node_modules/@smithy/middleware-content-length/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/@smithy/middleware-endpoint/dist-es/index.js + 10 modules
var middleware_endpoint_dist_es = __webpack_require__("./node_modules/@smithy/middleware-endpoint/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/@smithy/middleware-retry/dist-es/index.js + 15 modules
var middleware_retry_dist_es = __webpack_require__("./node_modules/@smithy/middleware-retry/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/@smithy/smithy-client/dist-es/index.js + 30 modules
var smithy_client_dist_es = __webpack_require__("./node_modules/@smithy/smithy-client/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-cloudwatch/dist-es/endpoint/EndpointParameters.js
var EndpointParameters = __webpack_require__("./node_modules/@aws-sdk/client-cloudwatch/dist-es/endpoint/EndpointParameters.js");
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-cloudwatch/package.json
const package_namespaceObject = /*#__PURE__*/JSON.parse('{"version":"3.490.0"}');
// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-sts/dist-es/defaultRoleAssumers.js + 16 modules
var defaultRoleAssumers = __webpack_require__("./node_modules/@aws-sdk/client-sts/dist-es/defaultRoleAssumers.js");
// EXTERNAL MODULE: ./node_modules/@aws-sdk/core/dist-es/client/emitWarningIfUnsupportedVersion.js
var emitWarningIfUnsupportedVersion = __webpack_require__("./node_modules/@aws-sdk/core/dist-es/client/emitWarningIfUnsupportedVersion.js");
// EXTERNAL MODULE: ./node_modules/@aws-sdk/credential-provider-node/dist-es/index.js + 33 modules
var credential_provider_node_dist_es = __webpack_require__("./node_modules/@aws-sdk/credential-provider-node/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/@aws-sdk/util-user-agent-node/dist-es/index.js + 2 modules
var util_user_agent_node_dist_es = __webpack_require__("./node_modules/@aws-sdk/util-user-agent-node/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/@smithy/hash-node/dist-es/index.js
var hash_node_dist_es = __webpack_require__("./node_modules/@smithy/hash-node/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/@smithy/node-config-provider/dist-es/index.js + 4 modules
var node_config_provider_dist_es = __webpack_require__("./node_modules/@smithy/node-config-provider/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/@smithy/node-http-handler/dist-es/index.js + 13 modules
var node_http_handler_dist_es = __webpack_require__("./node_modules/@smithy/node-http-handler/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/@smithy/util-body-length-node/dist-es/index.js + 1 modules
var util_body_length_node_dist_es = __webpack_require__("./node_modules/@smithy/util-body-length-node/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/@smithy/util-retry/dist-es/index.js + 8 modules
var util_retry_dist_es = __webpack_require__("./node_modules/@smithy/util-retry/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/@smithy/url-parser/dist-es/index.js + 1 modules
var url_parser_dist_es = __webpack_require__("./node_modules/@smithy/url-parser/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/@smithy/util-base64/dist-es/index.js + 2 modules
var util_base64_dist_es = __webpack_require__("./node_modules/@smithy/util-base64/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/@smithy/util-utf8/dist-es/index.js + 3 modules
var util_utf8_dist_es = __webpack_require__("./node_modules/@smithy/util-utf8/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/@smithy/util-endpoints/dist-es/index.js + 34 modules
var util_endpoints_dist_es = __webpack_require__("./node_modules/@smithy/util-endpoints/dist-es/index.js");
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-cloudwatch/dist-es/endpoint/ruleset.js
const u = "required", v = "fn", w = "argv", x = "ref";
const a = true, b = "isSet", c = "booleanEquals", d = "error", e = "endpoint", f = "tree", g = "PartitionResult", h = "getAttr", i = { [u]: false, "type": "String" }, j = { [u]: true, "default": false, "type": "Boolean" }, k = { [x]: "Endpoint" }, l = { [v]: c, [w]: [{ [x]: "UseFIPS" }, true] }, m = { [v]: c, [w]: [{ [x]: "UseDualStack" }, true] }, n = {}, o = { [v]: h, [w]: [{ [x]: g }, "supportsFIPS"] }, p = { [x]: g }, q = { [v]: c, [w]: [true, { [v]: h, [w]: [p, "supportsDualStack"] }] }, r = [l], s = [m], t = [{ [x]: "Region" }];
const _data = { version: "1.0", parameters: { Region: i, UseDualStack: j, UseFIPS: j, Endpoint: i }, rules: [{ conditions: [{ [v]: b, [w]: [k] }], rules: [{ conditions: r, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: d }, { conditions: s, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: d }, { endpoint: { url: k, properties: n, headers: n }, type: e }], type: f }, { conditions: [{ [v]: b, [w]: t }], rules: [{ conditions: [{ [v]: "aws.partition", [w]: t, assign: g }], rules: [{ conditions: [l, m], rules: [{ conditions: [{ [v]: c, [w]: [a, o] }, q], rules: [{ endpoint: { url: "https://monitoring-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: n, headers: n }, type: e }], type: f }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: d }], type: f }, { conditions: r, rules: [{ conditions: [{ [v]: c, [w]: [o, a] }], rules: [{ conditions: [{ [v]: "stringEquals", [w]: [{ [v]: h, [w]: [p, "name"] }, "aws-us-gov"] }], endpoint: { url: "https://monitoring.{Region}.amazonaws.com", properties: n, headers: n }, type: e }, { endpoint: { url: "https://monitoring-fips.{Region}.{PartitionResult#dnsSuffix}", properties: n, headers: n }, type: e }], type: f }, { error: "FIPS is enabled but this partition does not support FIPS", type: d }], type: f }, { conditions: s, rules: [{ conditions: [q], rules: [{ endpoint: { url: "https://monitoring.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: n, headers: n }, type: e }], type: f }, { error: "DualStack is enabled but this partition does not support DualStack", type: d }], type: f }, { endpoint: { url: "https://monitoring.{Region}.{PartitionResult#dnsSuffix}", properties: n, headers: n }, type: e }], type: f }], type: f }, { error: "Invalid Configuration: Missing Region", type: d }] };
const ruleSet = _data;

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-cloudwatch/dist-es/endpoint/endpointResolver.js


const defaultEndpointResolver = (endpointParams, context = {}) => {
    return (0,util_endpoints_dist_es.resolveEndpoint)(ruleSet, {
        endpointParams: endpointParams,
        logger: context.logger,
    });
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-cloudwatch/dist-es/runtimeConfig.shared.js





const getRuntimeConfig = (config) => {
    return {
        apiVersion: "2010-08-01",
        base64Decoder: config?.base64Decoder ?? util_base64_dist_es.fromBase64,
        base64Encoder: config?.base64Encoder ?? util_base64_dist_es.toBase64,
        disableHostPrefix: config?.disableHostPrefix ?? false,
        endpointProvider: config?.endpointProvider ?? defaultEndpointResolver,
        extensions: config?.extensions ?? [],
        logger: config?.logger ?? new smithy_client_dist_es.NoOpLogger(),
        serviceId: config?.serviceId ?? "CloudWatch",
        urlParser: config?.urlParser ?? url_parser_dist_es.parseUrl,
        utf8Decoder: config?.utf8Decoder ?? util_utf8_dist_es.fromUtf8,
        utf8Encoder: config?.utf8Encoder ?? util_utf8_dist_es.toUtf8,
    };
};

// EXTERNAL MODULE: ./node_modules/@smithy/util-defaults-mode-node/dist-es/index.js + 3 modules
var util_defaults_mode_node_dist_es = __webpack_require__("./node_modules/@smithy/util-defaults-mode-node/dist-es/index.js");
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-cloudwatch/dist-es/runtimeConfig.js
















const runtimeConfig_getRuntimeConfig = (config) => {
    (0,smithy_client_dist_es.emitWarningIfUnsupportedVersion)(process.version);
    const defaultsMode = (0,util_defaults_mode_node_dist_es.resolveDefaultsModeConfig)(config);
    const defaultConfigProvider = () => defaultsMode().then(smithy_client_dist_es.loadConfigsForDefaultMode);
    const clientSharedValues = getRuntimeConfig(config);
    (0,emitWarningIfUnsupportedVersion.emitWarningIfUnsupportedVersion)(process.version);
    return {
        ...clientSharedValues,
        ...config,
        runtime: "node",
        defaultsMode,
        bodyLengthChecker: config?.bodyLengthChecker ?? util_body_length_node_dist_es.calculateBodyLength,
        credentialDefaultProvider: config?.credentialDefaultProvider ?? (0,defaultRoleAssumers.decorateDefaultCredentialProvider)(credential_provider_node_dist_es.defaultProvider),
        defaultUserAgentProvider: config?.defaultUserAgentProvider ??
            (0,util_user_agent_node_dist_es.defaultUserAgent)({ serviceId: clientSharedValues.serviceId, clientVersion: package_namespaceObject.version }),
        maxAttempts: config?.maxAttempts ?? (0,node_config_provider_dist_es.loadConfig)(middleware_retry_dist_es.NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
        region: config?.region ?? (0,node_config_provider_dist_es.loadConfig)(config_resolver_dist_es.NODE_REGION_CONFIG_OPTIONS, config_resolver_dist_es.NODE_REGION_CONFIG_FILE_OPTIONS),
        requestHandler: config?.requestHandler ?? new node_http_handler_dist_es.NodeHttpHandler(defaultConfigProvider),
        retryMode: config?.retryMode ??
            (0,node_config_provider_dist_es.loadConfig)({
                ...middleware_retry_dist_es.NODE_RETRY_MODE_CONFIG_OPTIONS,
                default: async () => (await defaultConfigProvider()).retryMode || util_retry_dist_es.DEFAULT_RETRY_MODE,
            }),
        sha256: config?.sha256 ?? hash_node_dist_es.Hash.bind(null, "sha256"),
        streamCollector: config?.streamCollector ?? node_http_handler_dist_es.streamCollector,
        useDualstackEndpoint: config?.useDualstackEndpoint ?? (0,node_config_provider_dist_es.loadConfig)(config_resolver_dist_es.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
        useFipsEndpoint: config?.useFipsEndpoint ?? (0,node_config_provider_dist_es.loadConfig)(config_resolver_dist_es.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS),
    };
};

// EXTERNAL MODULE: ./node_modules/@aws-sdk/region-config-resolver/dist-es/index.js + 3 modules
var region_config_resolver_dist_es = __webpack_require__("./node_modules/@aws-sdk/region-config-resolver/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/@smithy/protocol-http/dist-es/index.js + 5 modules
var protocol_http_dist_es = __webpack_require__("./node_modules/@smithy/protocol-http/dist-es/index.js");
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-cloudwatch/dist-es/runtimeExtensions.js



const asPartial = (t) => t;
const resolveRuntimeExtensions = (runtimeConfig, extensions) => {
    const extensionConfiguration = {
        ...asPartial((0,region_config_resolver_dist_es.getAwsRegionExtensionConfiguration)(runtimeConfig)),
        ...asPartial((0,smithy_client_dist_es.getDefaultExtensionConfiguration)(runtimeConfig)),
        ...asPartial((0,protocol_http_dist_es.getHttpHandlerExtensionConfiguration)(runtimeConfig)),
    };
    extensions.forEach((extension) => extension.configure(extensionConfiguration));
    return {
        ...runtimeConfig,
        ...(0,region_config_resolver_dist_es.resolveAwsRegionExtensionConfiguration)(extensionConfiguration),
        ...(0,smithy_client_dist_es.resolveDefaultRuntimeConfig)(extensionConfiguration),
        ...(0,protocol_http_dist_es.resolveHttpHandlerRuntimeConfig)(extensionConfiguration),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-cloudwatch/dist-es/CloudWatchClient.js














class CloudWatchClient extends smithy_client_dist_es.Client {
    constructor(...[configuration]) {
        const _config_0 = runtimeConfig_getRuntimeConfig(configuration || {});
        const _config_1 = (0,EndpointParameters.resolveClientEndpointParameters)(_config_0);
        const _config_2 = (0,config_resolver_dist_es.resolveRegionConfig)(_config_1);
        const _config_3 = (0,middleware_endpoint_dist_es.resolveEndpointConfig)(_config_2);
        const _config_4 = (0,middleware_retry_dist_es.resolveRetryConfig)(_config_3);
        const _config_5 = (0,dist_es.resolveHostHeaderConfig)(_config_4);
        const _config_6 = (0,middleware_signing_dist_es.resolveAwsAuthConfig)(_config_5);
        const _config_7 = (0,middleware_user_agent_dist_es.resolveUserAgentConfig)(_config_6);
        const _config_8 = resolveRuntimeExtensions(_config_7, configuration?.extensions || []);
        super(_config_8);
        this.config = _config_8;
        this.middlewareStack.use((0,middleware_retry_dist_es.getRetryPlugin)(this.config));
        this.middlewareStack.use((0,middleware_content_length_dist_es.getContentLengthPlugin)(this.config));
        this.middlewareStack.use((0,dist_es.getHostHeaderPlugin)(this.config));
        this.middlewareStack.use((0,middleware_logger_dist_es.getLoggerPlugin)(this.config));
        this.middlewareStack.use((0,middleware_recursion_detection_dist_es.getRecursionDetectionPlugin)(this.config));
        this.middlewareStack.use((0,middleware_signing_dist_es.getAwsAuthPlugin)(this.config));
        this.middlewareStack.use((0,middleware_user_agent_dist_es.getUserAgentPlugin)(this.config));
    }
    destroy() {
        super.destroy();
    }
}


/***/ }),

/***/ "./node_modules/@aws-sdk/client-cloudwatch/dist-es/commands/PutMetricDataCommand.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  PutMetricDataCommand: () => (/* binding */ PutMetricDataCommand)
});

// UNUSED EXPORTS: $Command

// EXTERNAL MODULE: ./node_modules/@smithy/middleware-endpoint/dist-es/index.js + 10 modules
var dist_es = __webpack_require__("./node_modules/@smithy/middleware-endpoint/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/@smithy/middleware-serde/dist-es/index.js + 3 modules
var middleware_serde_dist_es = __webpack_require__("./node_modules/@smithy/middleware-serde/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/@smithy/smithy-client/dist-es/index.js + 30 modules
var smithy_client_dist_es = __webpack_require__("./node_modules/@smithy/smithy-client/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-cloudwatch/dist-es/endpoint/EndpointParameters.js
var EndpointParameters = __webpack_require__("./node_modules/@aws-sdk/client-cloudwatch/dist-es/endpoint/EndpointParameters.js");
// EXTERNAL MODULE: ./node_modules/@smithy/protocol-http/dist-es/index.js + 5 modules
var protocol_http_dist_es = __webpack_require__("./node_modules/@smithy/protocol-http/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/fast-xml-parser/src/fxp.js
var fxp = __webpack_require__("./node_modules/fast-xml-parser/src/fxp.js");
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-cloudwatch/dist-es/models/CloudWatchServiceException.js


class CloudWatchServiceException extends smithy_client_dist_es.ServiceException {
    constructor(options) {
        super(options);
        Object.setPrototypeOf(this, CloudWatchServiceException.prototype);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-cloudwatch/dist-es/models/models_0.js

const ActionsSuppressedBy = {
    Alarm: "Alarm",
    ExtensionPeriod: "ExtensionPeriod",
    WaitPeriod: "WaitPeriod",
};
const AlarmType = {
    CompositeAlarm: "CompositeAlarm",
    MetricAlarm: "MetricAlarm",
};
const HistoryItemType = {
    Action: "Action",
    ConfigurationUpdate: "ConfigurationUpdate",
    StateUpdate: "StateUpdate",
};
const StandardUnit = {
    Bits: "Bits",
    Bits_Second: "Bits/Second",
    Bytes: "Bytes",
    Bytes_Second: "Bytes/Second",
    Count: "Count",
    Count_Second: "Count/Second",
    Gigabits: "Gigabits",
    Gigabits_Second: "Gigabits/Second",
    Gigabytes: "Gigabytes",
    Gigabytes_Second: "Gigabytes/Second",
    Kilobits: "Kilobits",
    Kilobits_Second: "Kilobits/Second",
    Kilobytes: "Kilobytes",
    Kilobytes_Second: "Kilobytes/Second",
    Megabits: "Megabits",
    Megabits_Second: "Megabits/Second",
    Megabytes: "Megabytes",
    Megabytes_Second: "Megabytes/Second",
    Microseconds: "Microseconds",
    Milliseconds: "Milliseconds",
    None: "None",
    Percent: "Percent",
    Seconds: "Seconds",
    Terabits: "Terabits",
    Terabits_Second: "Terabits/Second",
    Terabytes: "Terabytes",
    Terabytes_Second: "Terabytes/Second",
};
const AnomalyDetectorStateValue = {
    PENDING_TRAINING: "PENDING_TRAINING",
    TRAINED: "TRAINED",
    TRAINED_INSUFFICIENT_DATA: "TRAINED_INSUFFICIENT_DATA",
};
const AnomalyDetectorType = {
    METRIC_MATH: "METRIC_MATH",
    SINGLE_METRIC: "SINGLE_METRIC",
};
const ComparisonOperator = {
    GreaterThanOrEqualToThreshold: "GreaterThanOrEqualToThreshold",
    GreaterThanThreshold: "GreaterThanThreshold",
    GreaterThanUpperThreshold: "GreaterThanUpperThreshold",
    LessThanLowerOrGreaterThanUpperThreshold: "LessThanLowerOrGreaterThanUpperThreshold",
    LessThanLowerThreshold: "LessThanLowerThreshold",
    LessThanOrEqualToThreshold: "LessThanOrEqualToThreshold",
    LessThanThreshold: "LessThanThreshold",
};
const StateValue = {
    ALARM: "ALARM",
    INSUFFICIENT_DATA: "INSUFFICIENT_DATA",
    OK: "OK",
};
class models_0_ConcurrentModificationException extends CloudWatchServiceException {
    constructor(opts) {
        super({
            name: "ConcurrentModificationException",
            $fault: "client",
            ...opts,
        });
        this.name = "ConcurrentModificationException";
        this.$fault = "client";
        Object.setPrototypeOf(this, models_0_ConcurrentModificationException.prototype);
        this.Message = opts.Message;
    }
}
class models_0_DashboardInvalidInputError extends CloudWatchServiceException {
    constructor(opts) {
        super({
            name: "DashboardInvalidInputError",
            $fault: "client",
            ...opts,
        });
        this.name = "DashboardInvalidInputError";
        this.$fault = "client";
        Object.setPrototypeOf(this, models_0_DashboardInvalidInputError.prototype);
        this.dashboardValidationMessages = opts.dashboardValidationMessages;
    }
}
class models_0_DashboardNotFoundError extends CloudWatchServiceException {
    constructor(opts) {
        super({
            name: "DashboardNotFoundError",
            $fault: "client",
            ...opts,
        });
        this.name = "DashboardNotFoundError";
        this.$fault = "client";
        Object.setPrototypeOf(this, models_0_DashboardNotFoundError.prototype);
    }
}
class models_0_ResourceNotFound extends CloudWatchServiceException {
    constructor(opts) {
        super({
            name: "ResourceNotFound",
            $fault: "client",
            ...opts,
        });
        this.name = "ResourceNotFound";
        this.$fault = "client";
        Object.setPrototypeOf(this, models_0_ResourceNotFound.prototype);
    }
}
class InternalServiceFault extends CloudWatchServiceException {
    constructor(opts) {
        super({
            name: "InternalServiceFault",
            $fault: "server",
            ...opts,
        });
        this.name = "InternalServiceFault";
        this.$fault = "server";
        Object.setPrototypeOf(this, InternalServiceFault.prototype);
        this.Message = opts.Message;
    }
}
class InvalidParameterCombinationException extends CloudWatchServiceException {
    constructor(opts) {
        super({
            name: "InvalidParameterCombinationException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidParameterCombinationException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidParameterCombinationException.prototype);
    }
}
class InvalidParameterValueException extends CloudWatchServiceException {
    constructor(opts) {
        super({
            name: "InvalidParameterValueException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidParameterValueException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidParameterValueException.prototype);
    }
}
class MissingRequiredParameterException extends CloudWatchServiceException {
    constructor(opts) {
        super({
            name: "MissingRequiredParameterException",
            $fault: "client",
            ...opts,
        });
        this.name = "MissingRequiredParameterException";
        this.$fault = "client";
        Object.setPrototypeOf(this, MissingRequiredParameterException.prototype);
    }
}
class models_0_ResourceNotFoundException extends CloudWatchServiceException {
    constructor(opts) {
        super({
            name: "ResourceNotFoundException",
            $fault: "client",
            ...opts,
        });
        this.name = "ResourceNotFoundException";
        this.$fault = "client";
        Object.setPrototypeOf(this, models_0_ResourceNotFoundException.prototype);
        this.ResourceType = opts.ResourceType;
        this.ResourceId = opts.ResourceId;
        this.Message = opts.Message;
    }
}
const ScanBy = {
    TIMESTAMP_ASCENDING: "TimestampAscending",
    TIMESTAMP_DESCENDING: "TimestampDescending",
};
class models_0_InvalidNextToken extends CloudWatchServiceException {
    constructor(opts) {
        super({
            name: "InvalidNextToken",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidNextToken";
        this.$fault = "client";
        Object.setPrototypeOf(this, models_0_InvalidNextToken.prototype);
    }
}
const EvaluationState = {
    PARTIAL_DATA: "PARTIAL_DATA",
};
const Statistic = {
    Average: "Average",
    Maximum: "Maximum",
    Minimum: "Minimum",
    SampleCount: "SampleCount",
    Sum: "Sum",
};
class models_0_LimitExceededException extends CloudWatchServiceException {
    constructor(opts) {
        super({
            name: "LimitExceededException",
            $fault: "client",
            ...opts,
        });
        this.name = "LimitExceededException";
        this.$fault = "client";
        Object.setPrototypeOf(this, models_0_LimitExceededException.prototype);
        this.Message = opts.Message;
    }
}
const StatusCode = {
    COMPLETE: "Complete",
    FORBIDDEN: "Forbidden",
    INTERNAL_ERROR: "InternalError",
    PARTIAL_DATA: "PartialData",
};
const MetricStreamOutputFormat = {
    JSON: "json",
    OPEN_TELEMETRY_0_7: "opentelemetry0.7",
    OPEN_TELEMETRY_1_0: "opentelemetry1.0",
};
const RecentlyActive = {
    PT3H: "PT3H",
};
class models_0_LimitExceededFault extends CloudWatchServiceException {
    constructor(opts) {
        super({
            name: "LimitExceededFault",
            $fault: "client",
            ...opts,
        });
        this.name = "LimitExceededFault";
        this.$fault = "client";
        Object.setPrototypeOf(this, models_0_LimitExceededFault.prototype);
    }
}
class models_0_InvalidFormatFault extends CloudWatchServiceException {
    constructor(opts) {
        super({
            name: "InvalidFormatFault",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidFormatFault";
        this.$fault = "client";
        Object.setPrototypeOf(this, models_0_InvalidFormatFault.prototype);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-cloudwatch/dist-es/protocols/Aws_query.js





const se_DeleteAlarmsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteAlarmsInput(input, context),
        [_A]: _DA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DeleteAnomalyDetectorCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteAnomalyDetectorInput(input, context),
        [_A]: _DAD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DeleteDashboardsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteDashboardsInput(input, context),
        [_A]: _DD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DeleteInsightRulesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteInsightRulesInput(input, context),
        [_A]: _DIR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DeleteMetricStreamCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteMetricStreamInput(input, context),
        [_A]: _DMS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DescribeAlarmHistoryCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeAlarmHistoryInput(input, context),
        [_A]: _DAH,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DescribeAlarmsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeAlarmsInput(input, context),
        [_A]: _DAe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DescribeAlarmsForMetricCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeAlarmsForMetricInput(input, context),
        [_A]: _DAFM,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DescribeAnomalyDetectorsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeAnomalyDetectorsInput(input, context),
        [_A]: _DADe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DescribeInsightRulesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeInsightRulesInput(input, context),
        [_A]: _DIRe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DisableAlarmActionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisableAlarmActionsInput(input, context),
        [_A]: _DAA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_DisableInsightRulesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisableInsightRulesInput(input, context),
        [_A]: _DIRi,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_EnableAlarmActionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_EnableAlarmActionsInput(input, context),
        [_A]: _EAA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_EnableInsightRulesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_EnableInsightRulesInput(input, context),
        [_A]: _EIR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_GetDashboardCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetDashboardInput(input, context),
        [_A]: _GD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_GetInsightRuleReportCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetInsightRuleReportInput(input, context),
        [_A]: _GIRR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_GetMetricDataCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetMetricDataInput(input, context),
        [_A]: _GMD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_GetMetricStatisticsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetMetricStatisticsInput(input, context),
        [_A]: _GMS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_GetMetricStreamCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetMetricStreamInput(input, context),
        [_A]: _GMSe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_GetMetricWidgetImageCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetMetricWidgetImageInput(input, context),
        [_A]: _GMWI,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ListDashboardsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListDashboardsInput(input, context),
        [_A]: _LD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ListManagedInsightRulesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListManagedInsightRulesInput(input, context),
        [_A]: _LMIR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ListMetricsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListMetricsInput(input, context),
        [_A]: _LM,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ListMetricStreamsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListMetricStreamsInput(input, context),
        [_A]: _LMS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_ListTagsForResourceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListTagsForResourceInput(input, context),
        [_A]: _LTFR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_PutAnomalyDetectorCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutAnomalyDetectorInput(input, context),
        [_A]: _PAD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_PutCompositeAlarmCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutCompositeAlarmInput(input, context),
        [_A]: _PCA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_PutDashboardCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutDashboardInput(input, context),
        [_A]: _PD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_PutInsightRuleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutInsightRuleInput(input, context),
        [_A]: _PIR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_PutManagedInsightRulesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutManagedInsightRulesInput(input, context),
        [_A]: _PMIR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_PutMetricAlarmCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutMetricAlarmInput(input, context),
        [_A]: _PMA,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_PutMetricDataCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutMetricDataInput(input, context),
        [_A]: _PMD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_PutMetricStreamCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutMetricStreamInput(input, context),
        [_A]: _PMS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_SetAlarmStateCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_SetAlarmStateInput(input, context),
        [_A]: _SAS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_StartMetricStreamsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_StartMetricStreamsInput(input, context),
        [_A]: _SMS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_StopMetricStreamsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_StopMetricStreamsInput(input, context),
        [_A]: _SMSt,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_TagResourceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_TagResourceInput(input, context),
        [_A]: _TR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const se_UntagResourceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UntagResourceInput(input, context),
        [_A]: _UR,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
const de_DeleteAlarmsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteAlarmsCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_DeleteAlarmsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ResourceNotFound":
        case "com.amazonaws.cloudwatch#ResourceNotFound":
            throw await de_ResourceNotFoundRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteAnomalyDetectorCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteAnomalyDetectorCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteAnomalyDetectorOutput(data.DeleteAnomalyDetectorResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DeleteAnomalyDetectorCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceError":
        case "com.amazonaws.cloudwatch#InternalServiceFault":
            throw await de_InternalServiceFaultRes(parsedOutput, context);
        case "InvalidParameterCombination":
        case "com.amazonaws.cloudwatch#InvalidParameterCombinationException":
            throw await de_InvalidParameterCombinationExceptionRes(parsedOutput, context);
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "MissingParameter":
        case "com.amazonaws.cloudwatch#MissingRequiredParameterException":
            throw await de_MissingRequiredParameterExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatch#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteDashboardsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteDashboardsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteDashboardsOutput(data.DeleteDashboardsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DeleteDashboardsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceError":
        case "com.amazonaws.cloudwatch#InternalServiceFault":
            throw await de_InternalServiceFaultRes(parsedOutput, context);
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "ResourceNotFound":
        case "com.amazonaws.cloudwatch#DashboardNotFoundError":
            throw await de_DashboardNotFoundErrorRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteInsightRulesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteInsightRulesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteInsightRulesOutput(data.DeleteInsightRulesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DeleteInsightRulesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "MissingParameter":
        case "com.amazonaws.cloudwatch#MissingRequiredParameterException":
            throw await de_MissingRequiredParameterExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteMetricStreamCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteMetricStreamCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteMetricStreamOutput(data.DeleteMetricStreamResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DeleteMetricStreamCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceError":
        case "com.amazonaws.cloudwatch#InternalServiceFault":
            throw await de_InternalServiceFaultRes(parsedOutput, context);
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "MissingParameter":
        case "com.amazonaws.cloudwatch#MissingRequiredParameterException":
            throw await de_MissingRequiredParameterExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DescribeAlarmHistoryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeAlarmHistoryCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeAlarmHistoryOutput(data.DescribeAlarmHistoryResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DescribeAlarmHistoryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidNextToken":
        case "com.amazonaws.cloudwatch#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DescribeAlarmsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeAlarmsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeAlarmsOutput(data.DescribeAlarmsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DescribeAlarmsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidNextToken":
        case "com.amazonaws.cloudwatch#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DescribeAlarmsForMetricCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeAlarmsForMetricCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeAlarmsForMetricOutput(data.DescribeAlarmsForMetricResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DescribeAlarmsForMetricCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
const de_DescribeAnomalyDetectorsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeAnomalyDetectorsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeAnomalyDetectorsOutput(data.DescribeAnomalyDetectorsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DescribeAnomalyDetectorsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceError":
        case "com.amazonaws.cloudwatch#InternalServiceFault":
            throw await de_InternalServiceFaultRes(parsedOutput, context);
        case "InvalidNextToken":
        case "com.amazonaws.cloudwatch#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        case "InvalidParameterCombination":
        case "com.amazonaws.cloudwatch#InvalidParameterCombinationException":
            throw await de_InvalidParameterCombinationExceptionRes(parsedOutput, context);
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DescribeInsightRulesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeInsightRulesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeInsightRulesOutput(data.DescribeInsightRulesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DescribeInsightRulesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidNextToken":
        case "com.amazonaws.cloudwatch#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DisableAlarmActionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DisableAlarmActionsCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_DisableAlarmActionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
const de_DisableInsightRulesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DisableInsightRulesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DisableInsightRulesOutput(data.DisableInsightRulesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DisableInsightRulesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "MissingParameter":
        case "com.amazonaws.cloudwatch#MissingRequiredParameterException":
            throw await de_MissingRequiredParameterExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_EnableAlarmActionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_EnableAlarmActionsCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_EnableAlarmActionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
const de_EnableInsightRulesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_EnableInsightRulesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_EnableInsightRulesOutput(data.EnableInsightRulesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_EnableInsightRulesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.cloudwatch#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "MissingParameter":
        case "com.amazonaws.cloudwatch#MissingRequiredParameterException":
            throw await de_MissingRequiredParameterExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetDashboardCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetDashboardCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetDashboardOutput(data.GetDashboardResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetDashboardCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceError":
        case "com.amazonaws.cloudwatch#InternalServiceFault":
            throw await de_InternalServiceFaultRes(parsedOutput, context);
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "ResourceNotFound":
        case "com.amazonaws.cloudwatch#DashboardNotFoundError":
            throw await de_DashboardNotFoundErrorRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetInsightRuleReportCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetInsightRuleReportCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetInsightRuleReportOutput(data.GetInsightRuleReportResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetInsightRuleReportCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "MissingParameter":
        case "com.amazonaws.cloudwatch#MissingRequiredParameterException":
            throw await de_MissingRequiredParameterExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatch#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetMetricDataCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetMetricDataCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetMetricDataOutput(data.GetMetricDataResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetMetricDataCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidNextToken":
        case "com.amazonaws.cloudwatch#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetMetricStatisticsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetMetricStatisticsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetMetricStatisticsOutput(data.GetMetricStatisticsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetMetricStatisticsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceError":
        case "com.amazonaws.cloudwatch#InternalServiceFault":
            throw await de_InternalServiceFaultRes(parsedOutput, context);
        case "InvalidParameterCombination":
        case "com.amazonaws.cloudwatch#InvalidParameterCombinationException":
            throw await de_InvalidParameterCombinationExceptionRes(parsedOutput, context);
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "MissingParameter":
        case "com.amazonaws.cloudwatch#MissingRequiredParameterException":
            throw await de_MissingRequiredParameterExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetMetricStreamCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetMetricStreamCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetMetricStreamOutput(data.GetMetricStreamResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetMetricStreamCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceError":
        case "com.amazonaws.cloudwatch#InternalServiceFault":
            throw await de_InternalServiceFaultRes(parsedOutput, context);
        case "InvalidParameterCombination":
        case "com.amazonaws.cloudwatch#InvalidParameterCombinationException":
            throw await de_InvalidParameterCombinationExceptionRes(parsedOutput, context);
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "MissingParameter":
        case "com.amazonaws.cloudwatch#MissingRequiredParameterException":
            throw await de_MissingRequiredParameterExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatch#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_GetMetricWidgetImageCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetMetricWidgetImageCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetMetricWidgetImageOutput(data.GetMetricWidgetImageResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetMetricWidgetImageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
const de_ListDashboardsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListDashboardsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListDashboardsOutput(data.ListDashboardsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListDashboardsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceError":
        case "com.amazonaws.cloudwatch#InternalServiceFault":
            throw await de_InternalServiceFaultRes(parsedOutput, context);
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListManagedInsightRulesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListManagedInsightRulesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListManagedInsightRulesOutput(data.ListManagedInsightRulesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListManagedInsightRulesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidNextToken":
        case "com.amazonaws.cloudwatch#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "MissingParameter":
        case "com.amazonaws.cloudwatch#MissingRequiredParameterException":
            throw await de_MissingRequiredParameterExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListMetricsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListMetricsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListMetricsOutput(data.ListMetricsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListMetricsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceError":
        case "com.amazonaws.cloudwatch#InternalServiceFault":
            throw await de_InternalServiceFaultRes(parsedOutput, context);
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListMetricStreamsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListMetricStreamsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListMetricStreamsOutput(data.ListMetricStreamsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListMetricStreamsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceError":
        case "com.amazonaws.cloudwatch#InternalServiceFault":
            throw await de_InternalServiceFaultRes(parsedOutput, context);
        case "InvalidNextToken":
        case "com.amazonaws.cloudwatch#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "MissingParameter":
        case "com.amazonaws.cloudwatch#MissingRequiredParameterException":
            throw await de_MissingRequiredParameterExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListTagsForResourceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListTagsForResourceOutput(data.ListTagsForResourceResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListTagsForResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceError":
        case "com.amazonaws.cloudwatch#InternalServiceFault":
            throw await de_InternalServiceFaultRes(parsedOutput, context);
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatch#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_PutAnomalyDetectorCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_PutAnomalyDetectorCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_PutAnomalyDetectorOutput(data.PutAnomalyDetectorResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_PutAnomalyDetectorCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceError":
        case "com.amazonaws.cloudwatch#InternalServiceFault":
            throw await de_InternalServiceFaultRes(parsedOutput, context);
        case "InvalidParameterCombination":
        case "com.amazonaws.cloudwatch#InvalidParameterCombinationException":
            throw await de_InvalidParameterCombinationExceptionRes(parsedOutput, context);
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.cloudwatch#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "MissingParameter":
        case "com.amazonaws.cloudwatch#MissingRequiredParameterException":
            throw await de_MissingRequiredParameterExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_PutCompositeAlarmCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_PutCompositeAlarmCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_PutCompositeAlarmCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.cloudwatch#LimitExceededFault":
            throw await de_LimitExceededFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_PutDashboardCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_PutDashboardCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_PutDashboardOutput(data.PutDashboardResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_PutDashboardCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceError":
        case "com.amazonaws.cloudwatch#InternalServiceFault":
            throw await de_InternalServiceFaultRes(parsedOutput, context);
        case "InvalidParameterInput":
        case "com.amazonaws.cloudwatch#DashboardInvalidInputError":
            throw await de_DashboardInvalidInputErrorRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_PutInsightRuleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_PutInsightRuleCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_PutInsightRuleOutput(data.PutInsightRuleResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_PutInsightRuleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.cloudwatch#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "MissingParameter":
        case "com.amazonaws.cloudwatch#MissingRequiredParameterException":
            throw await de_MissingRequiredParameterExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_PutManagedInsightRulesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_PutManagedInsightRulesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_PutManagedInsightRulesOutput(data.PutManagedInsightRulesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_PutManagedInsightRulesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "MissingParameter":
        case "com.amazonaws.cloudwatch#MissingRequiredParameterException":
            throw await de_MissingRequiredParameterExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_PutMetricAlarmCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_PutMetricAlarmCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_PutMetricAlarmCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.cloudwatch#LimitExceededFault":
            throw await de_LimitExceededFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_PutMetricDataCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_PutMetricDataCommandError(output, context);
    }
    await (0,smithy_client_dist_es.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_PutMetricDataCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceError":
        case "com.amazonaws.cloudwatch#InternalServiceFault":
            throw await de_InternalServiceFaultRes(parsedOutput, context);
        case "InvalidParameterCombination":
        case "com.amazonaws.cloudwatch#InvalidParameterCombinationException":
            throw await de_InvalidParameterCombinationExceptionRes(parsedOutput, context);
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "MissingParameter":
        case "com.amazonaws.cloudwatch#MissingRequiredParameterException":
            throw await de_MissingRequiredParameterExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_PutMetricStreamCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_PutMetricStreamCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_PutMetricStreamOutput(data.PutMetricStreamResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_PutMetricStreamCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModificationException":
        case "com.amazonaws.cloudwatch#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "InternalServiceError":
        case "com.amazonaws.cloudwatch#InternalServiceFault":
            throw await de_InternalServiceFaultRes(parsedOutput, context);
        case "InvalidParameterCombination":
        case "com.amazonaws.cloudwatch#InvalidParameterCombinationException":
            throw await de_InvalidParameterCombinationExceptionRes(parsedOutput, context);
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "MissingParameter":
        case "com.amazonaws.cloudwatch#MissingRequiredParameterException":
            throw await de_MissingRequiredParameterExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_SetAlarmStateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_SetAlarmStateCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_SetAlarmStateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidFormat":
        case "com.amazonaws.cloudwatch#InvalidFormatFault":
            throw await de_InvalidFormatFaultRes(parsedOutput, context);
        case "ResourceNotFound":
        case "com.amazonaws.cloudwatch#ResourceNotFound":
            throw await de_ResourceNotFoundRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_StartMetricStreamsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_StartMetricStreamsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_StartMetricStreamsOutput(data.StartMetricStreamsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_StartMetricStreamsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceError":
        case "com.amazonaws.cloudwatch#InternalServiceFault":
            throw await de_InternalServiceFaultRes(parsedOutput, context);
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "MissingParameter":
        case "com.amazonaws.cloudwatch#MissingRequiredParameterException":
            throw await de_MissingRequiredParameterExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_StopMetricStreamsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_StopMetricStreamsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_StopMetricStreamsOutput(data.StopMetricStreamsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_StopMetricStreamsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceError":
        case "com.amazonaws.cloudwatch#InternalServiceFault":
            throw await de_InternalServiceFaultRes(parsedOutput, context);
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "MissingParameter":
        case "com.amazonaws.cloudwatch#MissingRequiredParameterException":
            throw await de_MissingRequiredParameterExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_TagResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_TagResourceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_TagResourceOutput(data.TagResourceResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_TagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModificationException":
        case "com.amazonaws.cloudwatch#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "InternalServiceError":
        case "com.amazonaws.cloudwatch#InternalServiceFault":
            throw await de_InternalServiceFaultRes(parsedOutput, context);
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatch#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_UntagResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UntagResourceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UntagResourceOutput(data.UntagResourceResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_UntagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModificationException":
        case "com.amazonaws.cloudwatch#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "InternalServiceError":
        case "com.amazonaws.cloudwatch#InternalServiceFault":
            throw await de_InternalServiceFaultRes(parsedOutput, context);
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatch#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ConcurrentModificationExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ConcurrentModificationException(body.Error, context);
    const exception = new ConcurrentModificationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DashboardInvalidInputErrorRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DashboardInvalidInputError(body.Error, context);
    const exception = new DashboardInvalidInputError({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DashboardNotFoundErrorRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DashboardNotFoundError(body.Error, context);
    const exception = new DashboardNotFoundError({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InternalServiceFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InternalServiceFault(body.Error, context);
    const exception = new InternalServiceFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0,smithy_client_dist_es.decorateServiceException)(exception, body);
};
const de_InvalidFormatFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidFormatFault(body.Error, context);
    const exception = new InvalidFormatFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidNextTokenRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidNextToken(body.Error, context);
    const exception = new InvalidNextToken({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidParameterCombinationExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidParameterCombinationException(body.Error, context);
    const exception = new InvalidParameterCombinationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0,smithy_client_dist_es.decorateServiceException)(exception, body);
};
const de_InvalidParameterValueExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidParameterValueException(body.Error, context);
    const exception = new InvalidParameterValueException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0,smithy_client_dist_es.decorateServiceException)(exception, body);
};
const de_LimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_LimitExceededException(body.Error, context);
    const exception = new LimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_LimitExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_LimitExceededFault(body.Error, context);
    const exception = new LimitExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_MissingRequiredParameterExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_MissingRequiredParameterException(body.Error, context);
    const exception = new MissingRequiredParameterException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0,smithy_client_dist_es.decorateServiceException)(exception, body);
};
const de_ResourceNotFoundRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ResourceNotFound(body.Error, context);
    const exception = new ResourceNotFound({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ResourceNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ResourceNotFoundException(body.Error, context);
    const exception = new ResourceNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const se_AlarmNames = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_AlarmTypes = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_AnomalyDetectorConfiguration = (input, context) => {
    const entries = {};
    if (input[_ETR] != null) {
        const memberEntries = se_AnomalyDetectorExcludedTimeRanges(input[_ETR], context);
        if (input[_ETR]?.length === 0) {
            entries.ExcludedTimeRanges = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ExcludedTimeRanges.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MT] != null) {
        entries[_MT] = input[_MT];
    }
    return entries;
};
const se_AnomalyDetectorExcludedTimeRanges = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_Range(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_AnomalyDetectorTypes = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_Counts = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = (0,smithy_client_dist_es.serializeFloat)(entry);
        counter++;
    }
    return entries;
};
const se_DashboardNames = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_DeleteAlarmsInput = (input, context) => {
    const entries = {};
    if (input[_AN] != null) {
        const memberEntries = se_AlarmNames(input[_AN], context);
        if (input[_AN]?.length === 0) {
            entries.AlarmNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AlarmNames.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DeleteAnomalyDetectorInput = (input, context) => {
    const entries = {};
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    if (input[_MN] != null) {
        entries[_MN] = input[_MN];
    }
    if (input[_D] != null) {
        const memberEntries = se_Dimensions(input[_D], context);
        if (input[_D]?.length === 0) {
            entries.Dimensions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Dimensions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_S] != null) {
        entries[_S] = input[_S];
    }
    if (input[_SMAD] != null) {
        const memberEntries = se_SingleMetricAnomalyDetector(input[_SMAD], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SingleMetricAnomalyDetector.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MMAD] != null) {
        const memberEntries = se_MetricMathAnomalyDetector(input[_MMAD], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MetricMathAnomalyDetector.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DeleteDashboardsInput = (input, context) => {
    const entries = {};
    if (input[_DN] != null) {
        const memberEntries = se_DashboardNames(input[_DN], context);
        if (input[_DN]?.length === 0) {
            entries.DashboardNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `DashboardNames.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DeleteInsightRulesInput = (input, context) => {
    const entries = {};
    if (input[_RN] != null) {
        const memberEntries = se_InsightRuleNames(input[_RN], context);
        if (input[_RN]?.length === 0) {
            entries.RuleNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RuleNames.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DeleteMetricStreamInput = (input, context) => {
    const entries = {};
    if (input[_Na] != null) {
        entries[_Na] = input[_Na];
    }
    return entries;
};
const se_DescribeAlarmHistoryInput = (input, context) => {
    const entries = {};
    if (input[_ANl] != null) {
        entries[_ANl] = input[_ANl];
    }
    if (input[_AT] != null) {
        const memberEntries = se_AlarmTypes(input[_AT], context);
        if (input[_AT]?.length === 0) {
            entries.AlarmTypes = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AlarmTypes.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_HIT] != null) {
        entries[_HIT] = input[_HIT];
    }
    if (input[_SD] != null) {
        entries[_SD] = input[_SD].toISOString().split(".")[0] + "Z";
    }
    if (input[_ED] != null) {
        entries[_ED] = input[_ED].toISOString().split(".")[0] + "Z";
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_SB] != null) {
        entries[_SB] = input[_SB];
    }
    return entries;
};
const se_DescribeAlarmsForMetricInput = (input, context) => {
    const entries = {};
    if (input[_MN] != null) {
        entries[_MN] = input[_MN];
    }
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    if (input[_St] != null) {
        entries[_St] = input[_St];
    }
    if (input[_ES] != null) {
        entries[_ES] = input[_ES];
    }
    if (input[_D] != null) {
        const memberEntries = se_Dimensions(input[_D], context);
        if (input[_D]?.length === 0) {
            entries.Dimensions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Dimensions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_U] != null) {
        entries[_U] = input[_U];
    }
    return entries;
};
const se_DescribeAlarmsInput = (input, context) => {
    const entries = {};
    if (input[_AN] != null) {
        const memberEntries = se_AlarmNames(input[_AN], context);
        if (input[_AN]?.length === 0) {
            entries.AlarmNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AlarmNames.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_ANP] != null) {
        entries[_ANP] = input[_ANP];
    }
    if (input[_AT] != null) {
        const memberEntries = se_AlarmTypes(input[_AT], context);
        if (input[_AT]?.length === 0) {
            entries.AlarmTypes = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AlarmTypes.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_COAN] != null) {
        entries[_COAN] = input[_COAN];
    }
    if (input[_POAN] != null) {
        entries[_POAN] = input[_POAN];
    }
    if (input[_SV] != null) {
        entries[_SV] = input[_SV];
    }
    if (input[_AP] != null) {
        entries[_AP] = input[_AP];
    }
    if (input[_MR] != null) {
        entries[_MR] = input[_MR];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_DescribeAnomalyDetectorsInput = (input, context) => {
    const entries = {};
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MRa] != null) {
        entries[_MRa] = input[_MRa];
    }
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    if (input[_MN] != null) {
        entries[_MN] = input[_MN];
    }
    if (input[_D] != null) {
        const memberEntries = se_Dimensions(input[_D], context);
        if (input[_D]?.length === 0) {
            entries.Dimensions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Dimensions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_ADT] != null) {
        const memberEntries = se_AnomalyDetectorTypes(input[_ADT], context);
        if (input[_ADT]?.length === 0) {
            entries.AnomalyDetectorTypes = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AnomalyDetectorTypes.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeInsightRulesInput = (input, context) => {
    const entries = {};
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MRa] != null) {
        entries[_MRa] = input[_MRa];
    }
    return entries;
};
const se_Dimension = (input, context) => {
    const entries = {};
    if (input[_Na] != null) {
        entries[_Na] = input[_Na];
    }
    if (input[_Va] != null) {
        entries[_Va] = input[_Va];
    }
    return entries;
};
const se_DimensionFilter = (input, context) => {
    const entries = {};
    if (input[_Na] != null) {
        entries[_Na] = input[_Na];
    }
    if (input[_Va] != null) {
        entries[_Va] = input[_Va];
    }
    return entries;
};
const se_DimensionFilters = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_DimensionFilter(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_Dimensions = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_Dimension(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_DisableAlarmActionsInput = (input, context) => {
    const entries = {};
    if (input[_AN] != null) {
        const memberEntries = se_AlarmNames(input[_AN], context);
        if (input[_AN]?.length === 0) {
            entries.AlarmNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AlarmNames.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DisableInsightRulesInput = (input, context) => {
    const entries = {};
    if (input[_RN] != null) {
        const memberEntries = se_InsightRuleNames(input[_RN], context);
        if (input[_RN]?.length === 0) {
            entries.RuleNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RuleNames.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_EnableAlarmActionsInput = (input, context) => {
    const entries = {};
    if (input[_AN] != null) {
        const memberEntries = se_AlarmNames(input[_AN], context);
        if (input[_AN]?.length === 0) {
            entries.AlarmNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AlarmNames.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_EnableInsightRulesInput = (input, context) => {
    const entries = {};
    if (input[_RN] != null) {
        const memberEntries = se_InsightRuleNames(input[_RN], context);
        if (input[_RN]?.length === 0) {
            entries.RuleNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RuleNames.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ExtendedStatistics = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_GetDashboardInput = (input, context) => {
    const entries = {};
    if (input[_DNa] != null) {
        entries[_DNa] = input[_DNa];
    }
    return entries;
};
const se_GetInsightRuleReportInput = (input, context) => {
    const entries = {};
    if (input[_RNu] != null) {
        entries[_RNu] = input[_RNu];
    }
    if (input[_ST] != null) {
        entries[_ST] = input[_ST].toISOString().split(".")[0] + "Z";
    }
    if (input[_ET] != null) {
        entries[_ET] = input[_ET].toISOString().split(".")[0] + "Z";
    }
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_MCC] != null) {
        entries[_MCC] = input[_MCC];
    }
    if (input[_M] != null) {
        const memberEntries = se_InsightRuleMetricList(input[_M], context);
        if (input[_M]?.length === 0) {
            entries.Metrics = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Metrics.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_OB] != null) {
        entries[_OB] = input[_OB];
    }
    return entries;
};
const se_GetMetricDataInput = (input, context) => {
    const entries = {};
    if (input[_MDQ] != null) {
        const memberEntries = se_MetricDataQueries(input[_MDQ], context);
        if (input[_MDQ]?.length === 0) {
            entries.MetricDataQueries = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MetricDataQueries.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_ST] != null) {
        entries[_ST] = input[_ST].toISOString().split(".")[0] + "Z";
    }
    if (input[_ET] != null) {
        entries[_ET] = input[_ET].toISOString().split(".")[0] + "Z";
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_SB] != null) {
        entries[_SB] = input[_SB];
    }
    if (input[_MD] != null) {
        entries[_MD] = input[_MD];
    }
    if (input[_LO] != null) {
        const memberEntries = se_LabelOptions(input[_LO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LabelOptions.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_GetMetricStatisticsInput = (input, context) => {
    const entries = {};
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    if (input[_MN] != null) {
        entries[_MN] = input[_MN];
    }
    if (input[_D] != null) {
        const memberEntries = se_Dimensions(input[_D], context);
        if (input[_D]?.length === 0) {
            entries.Dimensions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Dimensions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_ST] != null) {
        entries[_ST] = input[_ST].toISOString().split(".")[0] + "Z";
    }
    if (input[_ET] != null) {
        entries[_ET] = input[_ET].toISOString().split(".")[0] + "Z";
    }
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_Sta] != null) {
        const memberEntries = se_Statistics(input[_Sta], context);
        if (input[_Sta]?.length === 0) {
            entries.Statistics = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Statistics.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_ESx] != null) {
        const memberEntries = se_ExtendedStatistics(input[_ESx], context);
        if (input[_ESx]?.length === 0) {
            entries.ExtendedStatistics = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ExtendedStatistics.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_U] != null) {
        entries[_U] = input[_U];
    }
    return entries;
};
const se_GetMetricStreamInput = (input, context) => {
    const entries = {};
    if (input[_Na] != null) {
        entries[_Na] = input[_Na];
    }
    return entries;
};
const se_GetMetricWidgetImageInput = (input, context) => {
    const entries = {};
    if (input[_MW] != null) {
        entries[_MW] = input[_MW];
    }
    if (input[_OF] != null) {
        entries[_OF] = input[_OF];
    }
    return entries;
};
const se_InsightRuleMetricList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_InsightRuleNames = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_LabelOptions = (input, context) => {
    const entries = {};
    if (input[_T] != null) {
        entries[_T] = input[_T];
    }
    return entries;
};
const se_ListDashboardsInput = (input, context) => {
    const entries = {};
    if (input[_DNP] != null) {
        entries[_DNP] = input[_DNP];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    return entries;
};
const se_ListManagedInsightRulesInput = (input, context) => {
    const entries = {};
    if (input[_RARN] != null) {
        entries[_RARN] = input[_RARN];
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MRa] != null) {
        entries[_MRa] = input[_MRa];
    }
    return entries;
};
const se_ListMetricsInput = (input, context) => {
    const entries = {};
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    if (input[_MN] != null) {
        entries[_MN] = input[_MN];
    }
    if (input[_D] != null) {
        const memberEntries = se_DimensionFilters(input[_D], context);
        if (input[_D]?.length === 0) {
            entries.Dimensions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Dimensions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_RA] != null) {
        entries[_RA] = input[_RA];
    }
    if (input[_ILA] != null) {
        entries[_ILA] = input[_ILA];
    }
    if (input[_OA] != null) {
        entries[_OA] = input[_OA];
    }
    return entries;
};
const se_ListMetricStreamsInput = (input, context) => {
    const entries = {};
    if (input[_NT] != null) {
        entries[_NT] = input[_NT];
    }
    if (input[_MRa] != null) {
        entries[_MRa] = input[_MRa];
    }
    return entries;
};
const se_ListTagsForResourceInput = (input, context) => {
    const entries = {};
    if (input[_RARN] != null) {
        entries[_RARN] = input[_RARN];
    }
    return entries;
};
const se_ManagedRule = (input, context) => {
    const entries = {};
    if (input[_TN] != null) {
        entries[_TN] = input[_TN];
    }
    if (input[_RARN] != null) {
        entries[_RARN] = input[_RARN];
    }
    if (input[_Ta] != null) {
        const memberEntries = se_TagList(input[_Ta], context);
        if (input[_Ta]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ManagedRules = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_ManagedRule(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_Metric = (input, context) => {
    const entries = {};
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    if (input[_MN] != null) {
        entries[_MN] = input[_MN];
    }
    if (input[_D] != null) {
        const memberEntries = se_Dimensions(input[_D], context);
        if (input[_D]?.length === 0) {
            entries.Dimensions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Dimensions.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_MetricData = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_MetricDatum(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_MetricDataQueries = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_MetricDataQuery(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_MetricDataQuery = (input, context) => {
    const entries = {};
    if (input[_I] != null) {
        entries[_I] = input[_I];
    }
    if (input[_MS] != null) {
        const memberEntries = se_MetricStat(input[_MS], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MetricStat.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_E] != null) {
        entries[_E] = input[_E];
    }
    if (input[_L] != null) {
        entries[_L] = input[_L];
    }
    if (input[_RD] != null) {
        entries[_RD] = input[_RD];
    }
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_AI] != null) {
        entries[_AI] = input[_AI];
    }
    return entries;
};
const se_MetricDatum = (input, context) => {
    const entries = {};
    if (input[_MN] != null) {
        entries[_MN] = input[_MN];
    }
    if (input[_D] != null) {
        const memberEntries = se_Dimensions(input[_D], context);
        if (input[_D]?.length === 0) {
            entries.Dimensions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Dimensions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_Ti] != null) {
        entries[_Ti] = input[_Ti].toISOString().split(".")[0] + "Z";
    }
    if (input[_Va] != null) {
        entries[_Va] = (0,smithy_client_dist_es.serializeFloat)(input[_Va]);
    }
    if (input[_SVt] != null) {
        const memberEntries = se_StatisticSet(input[_SVt], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `StatisticValues.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_Val] != null) {
        const memberEntries = se_Values(input[_Val], context);
        if (input[_Val]?.length === 0) {
            entries.Values = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Values.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_C] != null) {
        const memberEntries = se_Counts(input[_C], context);
        if (input[_C]?.length === 0) {
            entries.Counts = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Counts.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_U] != null) {
        entries[_U] = input[_U];
    }
    if (input[_SR] != null) {
        entries[_SR] = input[_SR];
    }
    return entries;
};
const se_MetricMathAnomalyDetector = (input, context) => {
    const entries = {};
    if (input[_MDQ] != null) {
        const memberEntries = se_MetricDataQueries(input[_MDQ], context);
        if (input[_MDQ]?.length === 0) {
            entries.MetricDataQueries = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MetricDataQueries.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_MetricStat = (input, context) => {
    const entries = {};
    if (input[_Me] != null) {
        const memberEntries = se_Metric(input[_Me], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Metric.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_S] != null) {
        entries[_S] = input[_S];
    }
    if (input[_U] != null) {
        entries[_U] = input[_U];
    }
    return entries;
};
const se_MetricStreamFilter = (input, context) => {
    const entries = {};
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    if (input[_MNe] != null) {
        const memberEntries = se_MetricStreamFilterMetricNames(input[_MNe], context);
        if (input[_MNe]?.length === 0) {
            entries.MetricNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MetricNames.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_MetricStreamFilterMetricNames = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_MetricStreamFilters = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_MetricStreamFilter(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_MetricStreamNames = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_MetricStreamStatisticsAdditionalStatistics = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_MetricStreamStatisticsConfiguration = (input, context) => {
    const entries = {};
    if (input[_IM] != null) {
        const memberEntries = se_MetricStreamStatisticsIncludeMetrics(input[_IM], context);
        if (input[_IM]?.length === 0) {
            entries.IncludeMetrics = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `IncludeMetrics.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_AS] != null) {
        const memberEntries = se_MetricStreamStatisticsAdditionalStatistics(input[_AS], context);
        if (input[_AS]?.length === 0) {
            entries.AdditionalStatistics = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AdditionalStatistics.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_MetricStreamStatisticsConfigurations = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_MetricStreamStatisticsConfiguration(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_MetricStreamStatisticsIncludeMetrics = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_MetricStreamStatisticsMetric(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_MetricStreamStatisticsMetric = (input, context) => {
    const entries = {};
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    if (input[_MN] != null) {
        entries[_MN] = input[_MN];
    }
    return entries;
};
const se_PutAnomalyDetectorInput = (input, context) => {
    const entries = {};
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    if (input[_MN] != null) {
        entries[_MN] = input[_MN];
    }
    if (input[_D] != null) {
        const memberEntries = se_Dimensions(input[_D], context);
        if (input[_D]?.length === 0) {
            entries.Dimensions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Dimensions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_S] != null) {
        entries[_S] = input[_S];
    }
    if (input[_Co] != null) {
        const memberEntries = se_AnomalyDetectorConfiguration(input[_Co], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Configuration.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_SMAD] != null) {
        const memberEntries = se_SingleMetricAnomalyDetector(input[_SMAD], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SingleMetricAnomalyDetector.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MMAD] != null) {
        const memberEntries = se_MetricMathAnomalyDetector(input[_MMAD], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MetricMathAnomalyDetector.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_PutCompositeAlarmInput = (input, context) => {
    const entries = {};
    if (input[_AE] != null) {
        entries[_AE] = input[_AE];
    }
    if (input[_AA] != null) {
        const memberEntries = se_ResourceList(input[_AA], context);
        if (input[_AA]?.length === 0) {
            entries.AlarmActions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AlarmActions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_AD] != null) {
        entries[_AD] = input[_AD];
    }
    if (input[_ANl] != null) {
        entries[_ANl] = input[_ANl];
    }
    if (input[_AR] != null) {
        entries[_AR] = input[_AR];
    }
    if (input[_IDA] != null) {
        const memberEntries = se_ResourceList(input[_IDA], context);
        if (input[_IDA]?.length === 0) {
            entries.InsufficientDataActions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InsufficientDataActions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_OKA] != null) {
        const memberEntries = se_ResourceList(input[_OKA], context);
        if (input[_OKA]?.length === 0) {
            entries.OKActions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `OKActions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_Ta] != null) {
        const memberEntries = se_TagList(input[_Ta], context);
        if (input[_Ta]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_ASc] != null) {
        entries[_ASc] = input[_ASc];
    }
    if (input[_ASWP] != null) {
        entries[_ASWP] = input[_ASWP];
    }
    if (input[_ASEP] != null) {
        entries[_ASEP] = input[_ASEP];
    }
    return entries;
};
const se_PutDashboardInput = (input, context) => {
    const entries = {};
    if (input[_DNa] != null) {
        entries[_DNa] = input[_DNa];
    }
    if (input[_DB] != null) {
        entries[_DB] = input[_DB];
    }
    return entries;
};
const se_PutInsightRuleInput = (input, context) => {
    const entries = {};
    if (input[_RNu] != null) {
        entries[_RNu] = input[_RNu];
    }
    if (input[_RS] != null) {
        entries[_RS] = input[_RS];
    }
    if (input[_RDu] != null) {
        entries[_RDu] = input[_RDu];
    }
    if (input[_Ta] != null) {
        const memberEntries = se_TagList(input[_Ta], context);
        if (input[_Ta]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_PutManagedInsightRulesInput = (input, context) => {
    const entries = {};
    if (input[_MRan] != null) {
        const memberEntries = se_ManagedRules(input[_MRan], context);
        if (input[_MRan]?.length === 0) {
            entries.ManagedRules = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ManagedRules.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_PutMetricAlarmInput = (input, context) => {
    const entries = {};
    if (input[_ANl] != null) {
        entries[_ANl] = input[_ANl];
    }
    if (input[_AD] != null) {
        entries[_AD] = input[_AD];
    }
    if (input[_AE] != null) {
        entries[_AE] = input[_AE];
    }
    if (input[_OKA] != null) {
        const memberEntries = se_ResourceList(input[_OKA], context);
        if (input[_OKA]?.length === 0) {
            entries.OKActions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `OKActions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_AA] != null) {
        const memberEntries = se_ResourceList(input[_AA], context);
        if (input[_AA]?.length === 0) {
            entries.AlarmActions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AlarmActions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_IDA] != null) {
        const memberEntries = se_ResourceList(input[_IDA], context);
        if (input[_IDA]?.length === 0) {
            entries.InsufficientDataActions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InsufficientDataActions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_MN] != null) {
        entries[_MN] = input[_MN];
    }
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    if (input[_St] != null) {
        entries[_St] = input[_St];
    }
    if (input[_ES] != null) {
        entries[_ES] = input[_ES];
    }
    if (input[_D] != null) {
        const memberEntries = se_Dimensions(input[_D], context);
        if (input[_D]?.length === 0) {
            entries.Dimensions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Dimensions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_P] != null) {
        entries[_P] = input[_P];
    }
    if (input[_U] != null) {
        entries[_U] = input[_U];
    }
    if (input[_EP] != null) {
        entries[_EP] = input[_EP];
    }
    if (input[_DTA] != null) {
        entries[_DTA] = input[_DTA];
    }
    if (input[_Th] != null) {
        entries[_Th] = __serializeFloat(input[_Th]);
    }
    if (input[_CO] != null) {
        entries[_CO] = input[_CO];
    }
    if (input[_TMD] != null) {
        entries[_TMD] = input[_TMD];
    }
    if (input[_ELSCP] != null) {
        entries[_ELSCP] = input[_ELSCP];
    }
    if (input[_M] != null) {
        const memberEntries = se_MetricDataQueries(input[_M], context);
        if (input[_M]?.length === 0) {
            entries.Metrics = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Metrics.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_Ta] != null) {
        const memberEntries = se_TagList(input[_Ta], context);
        if (input[_Ta]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_TMI] != null) {
        entries[_TMI] = input[_TMI];
    }
    return entries;
};
const se_PutMetricDataInput = (input, context) => {
    const entries = {};
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    if (input[_MDe] != null) {
        const memberEntries = se_MetricData(input[_MDe], context);
        if (input[_MDe]?.length === 0) {
            entries.MetricData = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MetricData.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_PutMetricStreamInput = (input, context) => {
    const entries = {};
    if (input[_Na] != null) {
        entries[_Na] = input[_Na];
    }
    if (input[_IF] != null) {
        const memberEntries = se_MetricStreamFilters(input[_IF], context);
        if (input[_IF]?.length === 0) {
            entries.IncludeFilters = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `IncludeFilters.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_EF] != null) {
        const memberEntries = se_MetricStreamFilters(input[_EF], context);
        if (input[_EF]?.length === 0) {
            entries.ExcludeFilters = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ExcludeFilters.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_FA] != null) {
        entries[_FA] = input[_FA];
    }
    if (input[_RAo] != null) {
        entries[_RAo] = input[_RAo];
    }
    if (input[_OF] != null) {
        entries[_OF] = input[_OF];
    }
    if (input[_Ta] != null) {
        const memberEntries = se_TagList(input[_Ta], context);
        if (input[_Ta]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_SC] != null) {
        const memberEntries = se_MetricStreamStatisticsConfigurations(input[_SC], context);
        if (input[_SC]?.length === 0) {
            entries.StatisticsConfigurations = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `StatisticsConfigurations.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_ILAM] != null) {
        entries[_ILAM] = input[_ILAM];
    }
    return entries;
};
const se_Range = (input, context) => {
    const entries = {};
    if (input[_ST] != null) {
        entries[_ST] = input[_ST].toISOString().split(".")[0] + "Z";
    }
    if (input[_ET] != null) {
        entries[_ET] = input[_ET].toISOString().split(".")[0] + "Z";
    }
    return entries;
};
const se_ResourceList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_SetAlarmStateInput = (input, context) => {
    const entries = {};
    if (input[_ANl] != null) {
        entries[_ANl] = input[_ANl];
    }
    if (input[_SV] != null) {
        entries[_SV] = input[_SV];
    }
    if (input[_SRt] != null) {
        entries[_SRt] = input[_SRt];
    }
    if (input[_SRD] != null) {
        entries[_SRD] = input[_SRD];
    }
    return entries;
};
const se_SingleMetricAnomalyDetector = (input, context) => {
    const entries = {};
    if (input[_N] != null) {
        entries[_N] = input[_N];
    }
    if (input[_MN] != null) {
        entries[_MN] = input[_MN];
    }
    if (input[_D] != null) {
        const memberEntries = se_Dimensions(input[_D], context);
        if (input[_D]?.length === 0) {
            entries.Dimensions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Dimensions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_S] != null) {
        entries[_S] = input[_S];
    }
    return entries;
};
const se_StartMetricStreamsInput = (input, context) => {
    const entries = {};
    if (input[_Nam] != null) {
        const memberEntries = se_MetricStreamNames(input[_Nam], context);
        if (input[_Nam]?.length === 0) {
            entries.Names = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Names.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_Statistics = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_StatisticSet = (input, context) => {
    const entries = {};
    if (input[_SCa] != null) {
        entries[_SCa] = (0,smithy_client_dist_es.serializeFloat)(input[_SCa]);
    }
    if (input[_Su] != null) {
        entries[_Su] = (0,smithy_client_dist_es.serializeFloat)(input[_Su]);
    }
    if (input[_Mi] != null) {
        entries[_Mi] = (0,smithy_client_dist_es.serializeFloat)(input[_Mi]);
    }
    if (input[_Ma] != null) {
        entries[_Ma] = (0,smithy_client_dist_es.serializeFloat)(input[_Ma]);
    }
    return entries;
};
const se_StopMetricStreamsInput = (input, context) => {
    const entries = {};
    if (input[_Nam] != null) {
        const memberEntries = se_MetricStreamNames(input[_Nam], context);
        if (input[_Nam]?.length === 0) {
            entries.Names = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Names.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_Tag = (input, context) => {
    const entries = {};
    if (input[_K] != null) {
        entries[_K] = input[_K];
    }
    if (input[_Va] != null) {
        entries[_Va] = input[_Va];
    }
    return entries;
};
const se_TagKeyList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_TagList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_Tag(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_TagResourceInput = (input, context) => {
    const entries = {};
    if (input[_RARN] != null) {
        entries[_RARN] = input[_RARN];
    }
    if (input[_Ta] != null) {
        const memberEntries = se_TagList(input[_Ta], context);
        if (input[_Ta]?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_UntagResourceInput = (input, context) => {
    const entries = {};
    if (input[_RARN] != null) {
        entries[_RARN] = input[_RARN];
    }
    if (input[_TK] != null) {
        const memberEntries = se_TagKeyList(input[_TK], context);
        if (input[_TK]?.length === 0) {
            entries.TagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagKeys.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_Values = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = (0,smithy_client_dist_es.serializeFloat)(entry);
        counter++;
    }
    return entries;
};
const de_AlarmHistoryItem = (output, context) => {
    const contents = {};
    if (output[_ANl] != null) {
        contents[_ANl] = __expectString(output[_ANl]);
    }
    if (output[_ATl] != null) {
        contents[_ATl] = __expectString(output[_ATl]);
    }
    if (output[_Ti] != null) {
        contents[_Ti] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_Ti]));
    }
    if (output[_HIT] != null) {
        contents[_HIT] = __expectString(output[_HIT]);
    }
    if (output[_HS] != null) {
        contents[_HS] = __expectString(output[_HS]);
    }
    if (output[_HD] != null) {
        contents[_HD] = __expectString(output[_HD]);
    }
    return contents;
};
const de_AlarmHistoryItems = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AlarmHistoryItem(entry, context);
    });
};
const de_AnomalyDetector = (output, context) => {
    const contents = {};
    if (output[_N] != null) {
        contents[_N] = __expectString(output[_N]);
    }
    if (output[_MN] != null) {
        contents[_MN] = __expectString(output[_MN]);
    }
    if (output.Dimensions === "") {
        contents[_D] = [];
    }
    else if (output[_D] != null && output[_D][_m] != null) {
        contents[_D] = de_Dimensions(__getArrayIfSingleItem(output[_D][_m]), context);
    }
    if (output[_S] != null) {
        contents[_S] = __expectString(output[_S]);
    }
    if (output[_Co] != null) {
        contents[_Co] = de_AnomalyDetectorConfiguration(output[_Co], context);
    }
    if (output[_SV] != null) {
        contents[_SV] = __expectString(output[_SV]);
    }
    if (output[_SMAD] != null) {
        contents[_SMAD] = de_SingleMetricAnomalyDetector(output[_SMAD], context);
    }
    if (output[_MMAD] != null) {
        contents[_MMAD] = de_MetricMathAnomalyDetector(output[_MMAD], context);
    }
    return contents;
};
const de_AnomalyDetectorConfiguration = (output, context) => {
    const contents = {};
    if (output.ExcludedTimeRanges === "") {
        contents[_ETR] = [];
    }
    else if (output[_ETR] != null && output[_ETR][_m] != null) {
        contents[_ETR] = de_AnomalyDetectorExcludedTimeRanges(__getArrayIfSingleItem(output[_ETR][_m]), context);
    }
    if (output[_MT] != null) {
        contents[_MT] = __expectString(output[_MT]);
    }
    return contents;
};
const de_AnomalyDetectorExcludedTimeRanges = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Range(entry, context);
    });
};
const de_AnomalyDetectors = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AnomalyDetector(entry, context);
    });
};
const de_BatchFailures = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PartialFailure(entry, context);
    });
};
const de_CompositeAlarm = (output, context) => {
    const contents = {};
    if (output[_AE] != null) {
        contents[_AE] = __parseBoolean(output[_AE]);
    }
    if (output.AlarmActions === "") {
        contents[_AA] = [];
    }
    else if (output[_AA] != null && output[_AA][_m] != null) {
        contents[_AA] = de_ResourceList(__getArrayIfSingleItem(output[_AA][_m]), context);
    }
    if (output[_AAl] != null) {
        contents[_AAl] = __expectString(output[_AAl]);
    }
    if (output[_ACUT] != null) {
        contents[_ACUT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_ACUT]));
    }
    if (output[_AD] != null) {
        contents[_AD] = __expectString(output[_AD]);
    }
    if (output[_ANl] != null) {
        contents[_ANl] = __expectString(output[_ANl]);
    }
    if (output[_AR] != null) {
        contents[_AR] = __expectString(output[_AR]);
    }
    if (output.InsufficientDataActions === "") {
        contents[_IDA] = [];
    }
    else if (output[_IDA] != null && output[_IDA][_m] != null) {
        contents[_IDA] = de_ResourceList(__getArrayIfSingleItem(output[_IDA][_m]), context);
    }
    if (output.OKActions === "") {
        contents[_OKA] = [];
    }
    else if (output[_OKA] != null && output[_OKA][_m] != null) {
        contents[_OKA] = de_ResourceList(__getArrayIfSingleItem(output[_OKA][_m]), context);
    }
    if (output[_SRt] != null) {
        contents[_SRt] = __expectString(output[_SRt]);
    }
    if (output[_SRD] != null) {
        contents[_SRD] = __expectString(output[_SRD]);
    }
    if (output[_SUT] != null) {
        contents[_SUT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_SUT]));
    }
    if (output[_SV] != null) {
        contents[_SV] = __expectString(output[_SV]);
    }
    if (output[_STT] != null) {
        contents[_STT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_STT]));
    }
    if (output[_ASB] != null) {
        contents[_ASB] = __expectString(output[_ASB]);
    }
    if (output[_ASR] != null) {
        contents[_ASR] = __expectString(output[_ASR]);
    }
    if (output[_ASc] != null) {
        contents[_ASc] = __expectString(output[_ASc]);
    }
    if (output[_ASWP] != null) {
        contents[_ASWP] = __strictParseInt32(output[_ASWP]);
    }
    if (output[_ASEP] != null) {
        contents[_ASEP] = __strictParseInt32(output[_ASEP]);
    }
    return contents;
};
const de_CompositeAlarms = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CompositeAlarm(entry, context);
    });
};
const de_ConcurrentModificationException = (output, context) => {
    const contents = {};
    if (output[_Mes] != null) {
        contents[_Mes] = __expectString(output[_Mes]);
    }
    return contents;
};
const de_DashboardEntries = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DashboardEntry(entry, context);
    });
};
const de_DashboardEntry = (output, context) => {
    const contents = {};
    if (output[_DNa] != null) {
        contents[_DNa] = __expectString(output[_DNa]);
    }
    if (output[_DAa] != null) {
        contents[_DAa] = __expectString(output[_DAa]);
    }
    if (output[_LMa] != null) {
        contents[_LMa] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_LMa]));
    }
    if (output[_Si] != null) {
        contents[_Si] = __strictParseLong(output[_Si]);
    }
    return contents;
};
const de_DashboardInvalidInputError = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    if (output.dashboardValidationMessages === "") {
        contents[_dVM] = [];
    }
    else if (output[_dVM] != null && output[_dVM][_m] != null) {
        contents[_dVM] = de_DashboardValidationMessages(__getArrayIfSingleItem(output[_dVM][_m]), context);
    }
    return contents;
};
const de_DashboardNotFoundError = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_DashboardValidationMessage = (output, context) => {
    const contents = {};
    if (output[_DP] != null) {
        contents[_DP] = __expectString(output[_DP]);
    }
    if (output[_Mes] != null) {
        contents[_Mes] = __expectString(output[_Mes]);
    }
    return contents;
};
const de_DashboardValidationMessages = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DashboardValidationMessage(entry, context);
    });
};
const de_Datapoint = (output, context) => {
    const contents = {};
    if (output[_Ti] != null) {
        contents[_Ti] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_Ti]));
    }
    if (output[_SCa] != null) {
        contents[_SCa] = __strictParseFloat(output[_SCa]);
    }
    if (output[_Av] != null) {
        contents[_Av] = __strictParseFloat(output[_Av]);
    }
    if (output[_Su] != null) {
        contents[_Su] = __strictParseFloat(output[_Su]);
    }
    if (output[_Mi] != null) {
        contents[_Mi] = __strictParseFloat(output[_Mi]);
    }
    if (output[_Ma] != null) {
        contents[_Ma] = __strictParseFloat(output[_Ma]);
    }
    if (output[_U] != null) {
        contents[_U] = __expectString(output[_U]);
    }
    if (output.ExtendedStatistics === "") {
        contents[_ESx] = {};
    }
    else if (output[_ESx] != null && output[_ESx][_e] != null) {
        contents[_ESx] = de_DatapointValueMap(__getArrayIfSingleItem(output[_ESx][_e]), context);
    }
    return contents;
};
const de_Datapoints = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Datapoint(entry, context);
    });
};
const de_DatapointValueMap = (output, context) => {
    return output.reduce((acc, pair) => {
        if (pair["value"] === null) {
            return acc;
        }
        acc[pair["key"]] = __strictParseFloat(pair["value"]);
        return acc;
    }, {});
};
const de_DatapointValues = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __strictParseFloat(entry);
    });
};
const de_DeleteAnomalyDetectorOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_DeleteDashboardsOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_DeleteInsightRulesOutput = (output, context) => {
    const contents = {};
    if (output.Failures === "") {
        contents[_F] = [];
    }
    else if (output[_F] != null && output[_F][_m] != null) {
        contents[_F] = de_BatchFailures(__getArrayIfSingleItem(output[_F][_m]), context);
    }
    return contents;
};
const de_DeleteMetricStreamOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_DescribeAlarmHistoryOutput = (output, context) => {
    const contents = {};
    if (output.AlarmHistoryItems === "") {
        contents[_AHI] = [];
    }
    else if (output[_AHI] != null && output[_AHI][_m] != null) {
        contents[_AHI] = de_AlarmHistoryItems(__getArrayIfSingleItem(output[_AHI][_m]), context);
    }
    if (output[_NT] != null) {
        contents[_NT] = __expectString(output[_NT]);
    }
    return contents;
};
const de_DescribeAlarmsForMetricOutput = (output, context) => {
    const contents = {};
    if (output.MetricAlarms === "") {
        contents[_MA] = [];
    }
    else if (output[_MA] != null && output[_MA][_m] != null) {
        contents[_MA] = de_MetricAlarms(__getArrayIfSingleItem(output[_MA][_m]), context);
    }
    return contents;
};
const de_DescribeAlarmsOutput = (output, context) => {
    const contents = {};
    if (output.CompositeAlarms === "") {
        contents[_CA] = [];
    }
    else if (output[_CA] != null && output[_CA][_m] != null) {
        contents[_CA] = de_CompositeAlarms(__getArrayIfSingleItem(output[_CA][_m]), context);
    }
    if (output.MetricAlarms === "") {
        contents[_MA] = [];
    }
    else if (output[_MA] != null && output[_MA][_m] != null) {
        contents[_MA] = de_MetricAlarms(__getArrayIfSingleItem(output[_MA][_m]), context);
    }
    if (output[_NT] != null) {
        contents[_NT] = __expectString(output[_NT]);
    }
    return contents;
};
const de_DescribeAnomalyDetectorsOutput = (output, context) => {
    const contents = {};
    if (output.AnomalyDetectors === "") {
        contents[_ADn] = [];
    }
    else if (output[_ADn] != null && output[_ADn][_m] != null) {
        contents[_ADn] = de_AnomalyDetectors(__getArrayIfSingleItem(output[_ADn][_m]), context);
    }
    if (output[_NT] != null) {
        contents[_NT] = __expectString(output[_NT]);
    }
    return contents;
};
const de_DescribeInsightRulesOutput = (output, context) => {
    const contents = {};
    if (output[_NT] != null) {
        contents[_NT] = __expectString(output[_NT]);
    }
    if (output.InsightRules === "") {
        contents[_IR] = [];
    }
    else if (output[_IR] != null && output[_IR][_m] != null) {
        contents[_IR] = de_InsightRules(__getArrayIfSingleItem(output[_IR][_m]), context);
    }
    return contents;
};
const de_Dimension = (output, context) => {
    const contents = {};
    if (output[_Na] != null) {
        contents[_Na] = __expectString(output[_Na]);
    }
    if (output[_Va] != null) {
        contents[_Va] = __expectString(output[_Va]);
    }
    return contents;
};
const de_Dimensions = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Dimension(entry, context);
    });
};
const de_DisableInsightRulesOutput = (output, context) => {
    const contents = {};
    if (output.Failures === "") {
        contents[_F] = [];
    }
    else if (output[_F] != null && output[_F][_m] != null) {
        contents[_F] = de_BatchFailures(__getArrayIfSingleItem(output[_F][_m]), context);
    }
    return contents;
};
const de_EnableInsightRulesOutput = (output, context) => {
    const contents = {};
    if (output.Failures === "") {
        contents[_F] = [];
    }
    else if (output[_F] != null && output[_F][_m] != null) {
        contents[_F] = de_BatchFailures(__getArrayIfSingleItem(output[_F][_m]), context);
    }
    return contents;
};
const de_GetDashboardOutput = (output, context) => {
    const contents = {};
    if (output[_DAa] != null) {
        contents[_DAa] = __expectString(output[_DAa]);
    }
    if (output[_DB] != null) {
        contents[_DB] = __expectString(output[_DB]);
    }
    if (output[_DNa] != null) {
        contents[_DNa] = __expectString(output[_DNa]);
    }
    return contents;
};
const de_GetInsightRuleReportOutput = (output, context) => {
    const contents = {};
    if (output.KeyLabels === "") {
        contents[_KL] = [];
    }
    else if (output[_KL] != null && output[_KL][_m] != null) {
        contents[_KL] = de_InsightRuleContributorKeyLabels(__getArrayIfSingleItem(output[_KL][_m]), context);
    }
    if (output[_ASg] != null) {
        contents[_ASg] = __expectString(output[_ASg]);
    }
    if (output[_AV] != null) {
        contents[_AV] = __strictParseFloat(output[_AV]);
    }
    if (output[_AUC] != null) {
        contents[_AUC] = __strictParseLong(output[_AUC]);
    }
    if (output.Contributors === "") {
        contents[_Con] = [];
    }
    else if (output[_Con] != null && output[_Con][_m] != null) {
        contents[_Con] = de_InsightRuleContributors(__getArrayIfSingleItem(output[_Con][_m]), context);
    }
    if (output.MetricDatapoints === "") {
        contents[_MDet] = [];
    }
    else if (output[_MDet] != null && output[_MDet][_m] != null) {
        contents[_MDet] = de_InsightRuleMetricDatapoints(__getArrayIfSingleItem(output[_MDet][_m]), context);
    }
    return contents;
};
const de_GetMetricDataOutput = (output, context) => {
    const contents = {};
    if (output.MetricDataResults === "") {
        contents[_MDR] = [];
    }
    else if (output[_MDR] != null && output[_MDR][_m] != null) {
        contents[_MDR] = de_MetricDataResults(__getArrayIfSingleItem(output[_MDR][_m]), context);
    }
    if (output[_NT] != null) {
        contents[_NT] = __expectString(output[_NT]);
    }
    if (output.Messages === "") {
        contents[_Mess] = [];
    }
    else if (output[_Mess] != null && output[_Mess][_m] != null) {
        contents[_Mess] = de_MetricDataResultMessages(__getArrayIfSingleItem(output[_Mess][_m]), context);
    }
    return contents;
};
const de_GetMetricStatisticsOutput = (output, context) => {
    const contents = {};
    if (output[_L] != null) {
        contents[_L] = __expectString(output[_L]);
    }
    if (output.Datapoints === "") {
        contents[_Da] = [];
    }
    else if (output[_Da] != null && output[_Da][_m] != null) {
        contents[_Da] = de_Datapoints(__getArrayIfSingleItem(output[_Da][_m]), context);
    }
    return contents;
};
const de_GetMetricStreamOutput = (output, context) => {
    const contents = {};
    if (output[_Ar] != null) {
        contents[_Ar] = __expectString(output[_Ar]);
    }
    if (output[_Na] != null) {
        contents[_Na] = __expectString(output[_Na]);
    }
    if (output.IncludeFilters === "") {
        contents[_IF] = [];
    }
    else if (output[_IF] != null && output[_IF][_m] != null) {
        contents[_IF] = de_MetricStreamFilters(__getArrayIfSingleItem(output[_IF][_m]), context);
    }
    if (output.ExcludeFilters === "") {
        contents[_EF] = [];
    }
    else if (output[_EF] != null && output[_EF][_m] != null) {
        contents[_EF] = de_MetricStreamFilters(__getArrayIfSingleItem(output[_EF][_m]), context);
    }
    if (output[_FA] != null) {
        contents[_FA] = __expectString(output[_FA]);
    }
    if (output[_RAo] != null) {
        contents[_RAo] = __expectString(output[_RAo]);
    }
    if (output[_Stat] != null) {
        contents[_Stat] = __expectString(output[_Stat]);
    }
    if (output[_CD] != null) {
        contents[_CD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_CD]));
    }
    if (output[_LUD] != null) {
        contents[_LUD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_LUD]));
    }
    if (output[_OF] != null) {
        contents[_OF] = __expectString(output[_OF]);
    }
    if (output.StatisticsConfigurations === "") {
        contents[_SC] = [];
    }
    else if (output[_SC] != null && output[_SC][_m] != null) {
        contents[_SC] = de_MetricStreamStatisticsConfigurations(__getArrayIfSingleItem(output[_SC][_m]), context);
    }
    if (output[_ILAM] != null) {
        contents[_ILAM] = __parseBoolean(output[_ILAM]);
    }
    return contents;
};
const de_GetMetricWidgetImageOutput = (output, context) => {
    const contents = {};
    if (output[_MWI] != null) {
        contents[_MWI] = context.base64Decoder(output[_MWI]);
    }
    return contents;
};
const de_InsightRule = (output, context) => {
    const contents = {};
    if (output[_Na] != null) {
        contents[_Na] = __expectString(output[_Na]);
    }
    if (output[_Stat] != null) {
        contents[_Stat] = __expectString(output[_Stat]);
    }
    if (output[_Sc] != null) {
        contents[_Sc] = __expectString(output[_Sc]);
    }
    if (output[_De] != null) {
        contents[_De] = __expectString(output[_De]);
    }
    if (output[_MRana] != null) {
        contents[_MRana] = __parseBoolean(output[_MRana]);
    }
    return contents;
};
const de_InsightRuleContributor = (output, context) => {
    const contents = {};
    if (output.Keys === "") {
        contents[_Ke] = [];
    }
    else if (output[_Ke] != null && output[_Ke][_m] != null) {
        contents[_Ke] = de_InsightRuleContributorKeys(__getArrayIfSingleItem(output[_Ke][_m]), context);
    }
    if (output[_AAV] != null) {
        contents[_AAV] = __strictParseFloat(output[_AAV]);
    }
    if (output.Datapoints === "") {
        contents[_Da] = [];
    }
    else if (output[_Da] != null && output[_Da][_m] != null) {
        contents[_Da] = de_InsightRuleContributorDatapoints(__getArrayIfSingleItem(output[_Da][_m]), context);
    }
    return contents;
};
const de_InsightRuleContributorDatapoint = (output, context) => {
    const contents = {};
    if (output[_Ti] != null) {
        contents[_Ti] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_Ti]));
    }
    if (output[_AVp] != null) {
        contents[_AVp] = __strictParseFloat(output[_AVp]);
    }
    return contents;
};
const de_InsightRuleContributorDatapoints = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InsightRuleContributorDatapoint(entry, context);
    });
};
const de_InsightRuleContributorKeyLabels = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_InsightRuleContributorKeys = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_InsightRuleContributors = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InsightRuleContributor(entry, context);
    });
};
const de_InsightRuleMetricDatapoint = (output, context) => {
    const contents = {};
    if (output[_Ti] != null) {
        contents[_Ti] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_Ti]));
    }
    if (output[_UC] != null) {
        contents[_UC] = __strictParseFloat(output[_UC]);
    }
    if (output[_MCV] != null) {
        contents[_MCV] = __strictParseFloat(output[_MCV]);
    }
    if (output[_SCa] != null) {
        contents[_SCa] = __strictParseFloat(output[_SCa]);
    }
    if (output[_Av] != null) {
        contents[_Av] = __strictParseFloat(output[_Av]);
    }
    if (output[_Su] != null) {
        contents[_Su] = __strictParseFloat(output[_Su]);
    }
    if (output[_Mi] != null) {
        contents[_Mi] = __strictParseFloat(output[_Mi]);
    }
    if (output[_Ma] != null) {
        contents[_Ma] = __strictParseFloat(output[_Ma]);
    }
    return contents;
};
const de_InsightRuleMetricDatapoints = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InsightRuleMetricDatapoint(entry, context);
    });
};
const de_InsightRules = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InsightRule(entry, context);
    });
};
const de_InternalServiceFault = (output, context) => {
    const contents = {};
    if (output[_Mes] != null) {
        contents[_Mes] = (0,smithy_client_dist_es.expectString)(output[_Mes]);
    }
    return contents;
};
const de_InvalidFormatFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_InvalidNextToken = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_InvalidParameterCombinationException = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = (0,smithy_client_dist_es.expectString)(output[_me]);
    }
    return contents;
};
const de_InvalidParameterValueException = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = (0,smithy_client_dist_es.expectString)(output[_me]);
    }
    return contents;
};
const de_LimitExceededException = (output, context) => {
    const contents = {};
    if (output[_Mes] != null) {
        contents[_Mes] = __expectString(output[_Mes]);
    }
    return contents;
};
const de_LimitExceededFault = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_ListDashboardsOutput = (output, context) => {
    const contents = {};
    if (output.DashboardEntries === "") {
        contents[_DE] = [];
    }
    else if (output[_DE] != null && output[_DE][_m] != null) {
        contents[_DE] = de_DashboardEntries(__getArrayIfSingleItem(output[_DE][_m]), context);
    }
    if (output[_NT] != null) {
        contents[_NT] = __expectString(output[_NT]);
    }
    return contents;
};
const de_ListManagedInsightRulesOutput = (output, context) => {
    const contents = {};
    if (output.ManagedRules === "") {
        contents[_MRan] = [];
    }
    else if (output[_MRan] != null && output[_MRan][_m] != null) {
        contents[_MRan] = de_ManagedRuleDescriptions(__getArrayIfSingleItem(output[_MRan][_m]), context);
    }
    if (output[_NT] != null) {
        contents[_NT] = __expectString(output[_NT]);
    }
    return contents;
};
const de_ListMetricsOutput = (output, context) => {
    const contents = {};
    if (output.Metrics === "") {
        contents[_M] = [];
    }
    else if (output[_M] != null && output[_M][_m] != null) {
        contents[_M] = de_Metrics(__getArrayIfSingleItem(output[_M][_m]), context);
    }
    if (output[_NT] != null) {
        contents[_NT] = __expectString(output[_NT]);
    }
    if (output.OwningAccounts === "") {
        contents[_OAw] = [];
    }
    else if (output[_OAw] != null && output[_OAw][_m] != null) {
        contents[_OAw] = de_OwningAccounts(__getArrayIfSingleItem(output[_OAw][_m]), context);
    }
    return contents;
};
const de_ListMetricStreamsOutput = (output, context) => {
    const contents = {};
    if (output[_NT] != null) {
        contents[_NT] = __expectString(output[_NT]);
    }
    if (output.Entries === "") {
        contents[_En] = [];
    }
    else if (output[_En] != null && output[_En][_m] != null) {
        contents[_En] = de_MetricStreamEntries(__getArrayIfSingleItem(output[_En][_m]), context);
    }
    return contents;
};
const de_ListTagsForResourceOutput = (output, context) => {
    const contents = {};
    if (output.Tags === "") {
        contents[_Ta] = [];
    }
    else if (output[_Ta] != null && output[_Ta][_m] != null) {
        contents[_Ta] = de_TagList(__getArrayIfSingleItem(output[_Ta][_m]), context);
    }
    return contents;
};
const de_ManagedRuleDescription = (output, context) => {
    const contents = {};
    if (output[_TN] != null) {
        contents[_TN] = __expectString(output[_TN]);
    }
    if (output[_RARN] != null) {
        contents[_RARN] = __expectString(output[_RARN]);
    }
    if (output[_RS] != null) {
        contents[_RS] = de_ManagedRuleState(output[_RS], context);
    }
    return contents;
};
const de_ManagedRuleDescriptions = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ManagedRuleDescription(entry, context);
    });
};
const de_ManagedRuleState = (output, context) => {
    const contents = {};
    if (output[_RNu] != null) {
        contents[_RNu] = __expectString(output[_RNu]);
    }
    if (output[_Stat] != null) {
        contents[_Stat] = __expectString(output[_Stat]);
    }
    return contents;
};
const de_MessageData = (output, context) => {
    const contents = {};
    if (output[_Cod] != null) {
        contents[_Cod] = __expectString(output[_Cod]);
    }
    if (output[_Va] != null) {
        contents[_Va] = __expectString(output[_Va]);
    }
    return contents;
};
const de_Metric = (output, context) => {
    const contents = {};
    if (output[_N] != null) {
        contents[_N] = __expectString(output[_N]);
    }
    if (output[_MN] != null) {
        contents[_MN] = __expectString(output[_MN]);
    }
    if (output.Dimensions === "") {
        contents[_D] = [];
    }
    else if (output[_D] != null && output[_D][_m] != null) {
        contents[_D] = de_Dimensions(__getArrayIfSingleItem(output[_D][_m]), context);
    }
    return contents;
};
const de_MetricAlarm = (output, context) => {
    const contents = {};
    if (output[_ANl] != null) {
        contents[_ANl] = __expectString(output[_ANl]);
    }
    if (output[_AAl] != null) {
        contents[_AAl] = __expectString(output[_AAl]);
    }
    if (output[_AD] != null) {
        contents[_AD] = __expectString(output[_AD]);
    }
    if (output[_ACUT] != null) {
        contents[_ACUT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_ACUT]));
    }
    if (output[_AE] != null) {
        contents[_AE] = __parseBoolean(output[_AE]);
    }
    if (output.OKActions === "") {
        contents[_OKA] = [];
    }
    else if (output[_OKA] != null && output[_OKA][_m] != null) {
        contents[_OKA] = de_ResourceList(__getArrayIfSingleItem(output[_OKA][_m]), context);
    }
    if (output.AlarmActions === "") {
        contents[_AA] = [];
    }
    else if (output[_AA] != null && output[_AA][_m] != null) {
        contents[_AA] = de_ResourceList(__getArrayIfSingleItem(output[_AA][_m]), context);
    }
    if (output.InsufficientDataActions === "") {
        contents[_IDA] = [];
    }
    else if (output[_IDA] != null && output[_IDA][_m] != null) {
        contents[_IDA] = de_ResourceList(__getArrayIfSingleItem(output[_IDA][_m]), context);
    }
    if (output[_SV] != null) {
        contents[_SV] = __expectString(output[_SV]);
    }
    if (output[_SRt] != null) {
        contents[_SRt] = __expectString(output[_SRt]);
    }
    if (output[_SRD] != null) {
        contents[_SRD] = __expectString(output[_SRD]);
    }
    if (output[_SUT] != null) {
        contents[_SUT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_SUT]));
    }
    if (output[_MN] != null) {
        contents[_MN] = __expectString(output[_MN]);
    }
    if (output[_N] != null) {
        contents[_N] = __expectString(output[_N]);
    }
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    if (output[_ES] != null) {
        contents[_ES] = __expectString(output[_ES]);
    }
    if (output.Dimensions === "") {
        contents[_D] = [];
    }
    else if (output[_D] != null && output[_D][_m] != null) {
        contents[_D] = de_Dimensions(__getArrayIfSingleItem(output[_D][_m]), context);
    }
    if (output[_P] != null) {
        contents[_P] = __strictParseInt32(output[_P]);
    }
    if (output[_U] != null) {
        contents[_U] = __expectString(output[_U]);
    }
    if (output[_EP] != null) {
        contents[_EP] = __strictParseInt32(output[_EP]);
    }
    if (output[_DTA] != null) {
        contents[_DTA] = __strictParseInt32(output[_DTA]);
    }
    if (output[_Th] != null) {
        contents[_Th] = __strictParseFloat(output[_Th]);
    }
    if (output[_CO] != null) {
        contents[_CO] = __expectString(output[_CO]);
    }
    if (output[_TMD] != null) {
        contents[_TMD] = __expectString(output[_TMD]);
    }
    if (output[_ELSCP] != null) {
        contents[_ELSCP] = __expectString(output[_ELSCP]);
    }
    if (output.Metrics === "") {
        contents[_M] = [];
    }
    else if (output[_M] != null && output[_M][_m] != null) {
        contents[_M] = de_MetricDataQueries(__getArrayIfSingleItem(output[_M][_m]), context);
    }
    if (output[_TMI] != null) {
        contents[_TMI] = __expectString(output[_TMI]);
    }
    if (output[_ESv] != null) {
        contents[_ESv] = __expectString(output[_ESv]);
    }
    if (output[_STT] != null) {
        contents[_STT] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_STT]));
    }
    return contents;
};
const de_MetricAlarms = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MetricAlarm(entry, context);
    });
};
const de_MetricDataQueries = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MetricDataQuery(entry, context);
    });
};
const de_MetricDataQuery = (output, context) => {
    const contents = {};
    if (output[_I] != null) {
        contents[_I] = __expectString(output[_I]);
    }
    if (output[_MS] != null) {
        contents[_MS] = de_MetricStat(output[_MS], context);
    }
    if (output[_E] != null) {
        contents[_E] = __expectString(output[_E]);
    }
    if (output[_L] != null) {
        contents[_L] = __expectString(output[_L]);
    }
    if (output[_RD] != null) {
        contents[_RD] = __parseBoolean(output[_RD]);
    }
    if (output[_P] != null) {
        contents[_P] = __strictParseInt32(output[_P]);
    }
    if (output[_AI] != null) {
        contents[_AI] = __expectString(output[_AI]);
    }
    return contents;
};
const de_MetricDataResult = (output, context) => {
    const contents = {};
    if (output[_I] != null) {
        contents[_I] = __expectString(output[_I]);
    }
    if (output[_L] != null) {
        contents[_L] = __expectString(output[_L]);
    }
    if (output.Timestamps === "") {
        contents[_Tim] = [];
    }
    else if (output[_Tim] != null && output[_Tim][_m] != null) {
        contents[_Tim] = de_Timestamps(__getArrayIfSingleItem(output[_Tim][_m]), context);
    }
    if (output.Values === "") {
        contents[_Val] = [];
    }
    else if (output[_Val] != null && output[_Val][_m] != null) {
        contents[_Val] = de_DatapointValues(__getArrayIfSingleItem(output[_Val][_m]), context);
    }
    if (output[_SCt] != null) {
        contents[_SCt] = __expectString(output[_SCt]);
    }
    if (output.Messages === "") {
        contents[_Mess] = [];
    }
    else if (output[_Mess] != null && output[_Mess][_m] != null) {
        contents[_Mess] = de_MetricDataResultMessages(__getArrayIfSingleItem(output[_Mess][_m]), context);
    }
    return contents;
};
const de_MetricDataResultMessages = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MessageData(entry, context);
    });
};
const de_MetricDataResults = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MetricDataResult(entry, context);
    });
};
const de_MetricMathAnomalyDetector = (output, context) => {
    const contents = {};
    if (output.MetricDataQueries === "") {
        contents[_MDQ] = [];
    }
    else if (output[_MDQ] != null && output[_MDQ][_m] != null) {
        contents[_MDQ] = de_MetricDataQueries(__getArrayIfSingleItem(output[_MDQ][_m]), context);
    }
    return contents;
};
const de_Metrics = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Metric(entry, context);
    });
};
const de_MetricStat = (output, context) => {
    const contents = {};
    if (output[_Me] != null) {
        contents[_Me] = de_Metric(output[_Me], context);
    }
    if (output[_P] != null) {
        contents[_P] = __strictParseInt32(output[_P]);
    }
    if (output[_S] != null) {
        contents[_S] = __expectString(output[_S]);
    }
    if (output[_U] != null) {
        contents[_U] = __expectString(output[_U]);
    }
    return contents;
};
const de_MetricStreamEntries = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MetricStreamEntry(entry, context);
    });
};
const de_MetricStreamEntry = (output, context) => {
    const contents = {};
    if (output[_Ar] != null) {
        contents[_Ar] = __expectString(output[_Ar]);
    }
    if (output[_CD] != null) {
        contents[_CD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_CD]));
    }
    if (output[_LUD] != null) {
        contents[_LUD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_LUD]));
    }
    if (output[_Na] != null) {
        contents[_Na] = __expectString(output[_Na]);
    }
    if (output[_FA] != null) {
        contents[_FA] = __expectString(output[_FA]);
    }
    if (output[_Stat] != null) {
        contents[_Stat] = __expectString(output[_Stat]);
    }
    if (output[_OF] != null) {
        contents[_OF] = __expectString(output[_OF]);
    }
    return contents;
};
const de_MetricStreamFilter = (output, context) => {
    const contents = {};
    if (output[_N] != null) {
        contents[_N] = __expectString(output[_N]);
    }
    if (output.MetricNames === "") {
        contents[_MNe] = [];
    }
    else if (output[_MNe] != null && output[_MNe][_m] != null) {
        contents[_MNe] = de_MetricStreamFilterMetricNames(__getArrayIfSingleItem(output[_MNe][_m]), context);
    }
    return contents;
};
const de_MetricStreamFilterMetricNames = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_MetricStreamFilters = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MetricStreamFilter(entry, context);
    });
};
const de_MetricStreamStatisticsAdditionalStatistics = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_MetricStreamStatisticsConfiguration = (output, context) => {
    const contents = {};
    if (output.IncludeMetrics === "") {
        contents[_IM] = [];
    }
    else if (output[_IM] != null && output[_IM][_m] != null) {
        contents[_IM] = de_MetricStreamStatisticsIncludeMetrics(__getArrayIfSingleItem(output[_IM][_m]), context);
    }
    if (output.AdditionalStatistics === "") {
        contents[_AS] = [];
    }
    else if (output[_AS] != null && output[_AS][_m] != null) {
        contents[_AS] = de_MetricStreamStatisticsAdditionalStatistics(__getArrayIfSingleItem(output[_AS][_m]), context);
    }
    return contents;
};
const de_MetricStreamStatisticsConfigurations = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MetricStreamStatisticsConfiguration(entry, context);
    });
};
const de_MetricStreamStatisticsIncludeMetrics = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MetricStreamStatisticsMetric(entry, context);
    });
};
const de_MetricStreamStatisticsMetric = (output, context) => {
    const contents = {};
    if (output[_N] != null) {
        contents[_N] = __expectString(output[_N]);
    }
    if (output[_MN] != null) {
        contents[_MN] = __expectString(output[_MN]);
    }
    return contents;
};
const de_MissingRequiredParameterException = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = (0,smithy_client_dist_es.expectString)(output[_me]);
    }
    return contents;
};
const de_OwningAccounts = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_PartialFailure = (output, context) => {
    const contents = {};
    if (output[_FR] != null) {
        contents[_FR] = __expectString(output[_FR]);
    }
    if (output[_ETx] != null) {
        contents[_ETx] = __expectString(output[_ETx]);
    }
    if (output[_FC] != null) {
        contents[_FC] = __expectString(output[_FC]);
    }
    if (output[_FD] != null) {
        contents[_FD] = __expectString(output[_FD]);
    }
    return contents;
};
const de_PutAnomalyDetectorOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_PutDashboardOutput = (output, context) => {
    const contents = {};
    if (output.DashboardValidationMessages === "") {
        contents[_DVM] = [];
    }
    else if (output[_DVM] != null && output[_DVM][_m] != null) {
        contents[_DVM] = de_DashboardValidationMessages(__getArrayIfSingleItem(output[_DVM][_m]), context);
    }
    return contents;
};
const de_PutInsightRuleOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_PutManagedInsightRulesOutput = (output, context) => {
    const contents = {};
    if (output.Failures === "") {
        contents[_F] = [];
    }
    else if (output[_F] != null && output[_F][_m] != null) {
        contents[_F] = de_BatchFailures(__getArrayIfSingleItem(output[_F][_m]), context);
    }
    return contents;
};
const de_PutMetricStreamOutput = (output, context) => {
    const contents = {};
    if (output[_Ar] != null) {
        contents[_Ar] = __expectString(output[_Ar]);
    }
    return contents;
};
const de_Range = (output, context) => {
    const contents = {};
    if (output[_ST] != null) {
        contents[_ST] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_ST]));
    }
    if (output[_ET] != null) {
        contents[_ET] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_ET]));
    }
    return contents;
};
const de_ResourceList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_ResourceNotFound = (output, context) => {
    const contents = {};
    if (output[_me] != null) {
        contents[_me] = __expectString(output[_me]);
    }
    return contents;
};
const de_ResourceNotFoundException = (output, context) => {
    const contents = {};
    if (output[_RT] != null) {
        contents[_RT] = __expectString(output[_RT]);
    }
    if (output[_RI] != null) {
        contents[_RI] = __expectString(output[_RI]);
    }
    if (output[_Mes] != null) {
        contents[_Mes] = __expectString(output[_Mes]);
    }
    return contents;
};
const de_SingleMetricAnomalyDetector = (output, context) => {
    const contents = {};
    if (output[_N] != null) {
        contents[_N] = __expectString(output[_N]);
    }
    if (output[_MN] != null) {
        contents[_MN] = __expectString(output[_MN]);
    }
    if (output.Dimensions === "") {
        contents[_D] = [];
    }
    else if (output[_D] != null && output[_D][_m] != null) {
        contents[_D] = de_Dimensions(__getArrayIfSingleItem(output[_D][_m]), context);
    }
    if (output[_S] != null) {
        contents[_S] = __expectString(output[_S]);
    }
    return contents;
};
const de_StartMetricStreamsOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_StopMetricStreamsOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_Tag = (output, context) => {
    const contents = {};
    if (output[_K] != null) {
        contents[_K] = __expectString(output[_K]);
    }
    if (output[_Va] != null) {
        contents[_Va] = __expectString(output[_Va]);
    }
    return contents;
};
const de_TagList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Tag(entry, context);
    });
};
const de_TagResourceOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_Timestamps = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectNonNull(__parseRfc3339DateTimeWithOffset(entry));
    });
};
const de_UntagResourceOutput = (output, context) => {
    const contents = {};
    return contents;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => (0,smithy_client_dist_es.collectBody)(streamBody, context).then((body) => context.utf8Encoder(body));
const throwDefaultError = (0,smithy_client_dist_es.withBaseException)(CloudWatchServiceException);
const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
        headers,
    };
    if (resolvedHostname !== undefined) {
        contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
        contents.body = body;
    }
    return new protocol_http_dist_es.HttpRequest(contents);
};
const SHARED_HEADERS = {
    "content-type": "application/x-www-form-urlencoded",
};
const _ = "2010-08-01";
const _A = "Action";
const _AA = "AlarmActions";
const _AAV = "ApproximateAggregateValue";
const _AAl = "AlarmArn";
const _ACUT = "AlarmConfigurationUpdatedTimestamp";
const _AD = "AlarmDescription";
const _ADT = "AnomalyDetectorTypes";
const _ADn = "AnomalyDetectors";
const _AE = "ActionsEnabled";
const _AHI = "AlarmHistoryItems";
const _AI = "AccountId";
const _AN = "AlarmNames";
const _ANP = "AlarmNamePrefix";
const _ANl = "AlarmName";
const _AP = "ActionPrefix";
const _AR = "AlarmRule";
const _AS = "AdditionalStatistics";
const _ASB = "ActionsSuppressedBy";
const _ASEP = "ActionsSuppressorExtensionPeriod";
const _ASR = "ActionsSuppressedReason";
const _ASWP = "ActionsSuppressorWaitPeriod";
const _ASc = "ActionsSuppressor";
const _ASg = "AggregationStatistic";
const _AT = "AlarmTypes";
const _ATl = "AlarmType";
const _AUC = "ApproximateUniqueCount";
const _AV = "AggregateValue";
const _AVp = "ApproximateValue";
const _Ar = "Arn";
const _Av = "Average";
const _C = "Counts";
const _CA = "CompositeAlarms";
const _CD = "CreationDate";
const _CO = "ComparisonOperator";
const _COAN = "ChildrenOfAlarmName";
const _Co = "Configuration";
const _Cod = "Code";
const _Con = "Contributors";
const _D = "Dimensions";
const _DA = "DeleteAlarms";
const _DAA = "DisableAlarmActions";
const _DAD = "DeleteAnomalyDetector";
const _DADe = "DescribeAnomalyDetectors";
const _DAFM = "DescribeAlarmsForMetric";
const _DAH = "DescribeAlarmHistory";
const _DAa = "DashboardArn";
const _DAe = "DescribeAlarms";
const _DB = "DashboardBody";
const _DD = "DeleteDashboards";
const _DE = "DashboardEntries";
const _DIR = "DeleteInsightRules";
const _DIRe = "DescribeInsightRules";
const _DIRi = "DisableInsightRules";
const _DMS = "DeleteMetricStream";
const _DN = "DashboardNames";
const _DNP = "DashboardNamePrefix";
const _DNa = "DashboardName";
const _DP = "DataPath";
const _DTA = "DatapointsToAlarm";
const _DVM = "DashboardValidationMessages";
const _Da = "Datapoints";
const _De = "Definition";
const _E = "Expression";
const _EAA = "EnableAlarmActions";
const _ED = "EndDate";
const _EF = "ExcludeFilters";
const _EIR = "EnableInsightRules";
const _ELSCP = "EvaluateLowSampleCountPercentile";
const _EP = "EvaluationPeriods";
const _ES = "ExtendedStatistic";
const _ESv = "EvaluationState";
const _ESx = "ExtendedStatistics";
const _ET = "EndTime";
const _ETR = "ExcludedTimeRanges";
const _ETx = "ExceptionType";
const _En = "Entries";
const _F = "Failures";
const _FA = "FirehoseArn";
const _FC = "FailureCode";
const _FD = "FailureDescription";
const _FR = "FailureResource";
const _GD = "GetDashboard";
const _GIRR = "GetInsightRuleReport";
const _GMD = "GetMetricData";
const _GMS = "GetMetricStatistics";
const _GMSe = "GetMetricStream";
const _GMWI = "GetMetricWidgetImage";
const _HD = "HistoryData";
const _HIT = "HistoryItemType";
const _HS = "HistorySummary";
const _I = "Id";
const _IDA = "InsufficientDataActions";
const _IF = "IncludeFilters";
const _ILA = "IncludeLinkedAccounts";
const _ILAM = "IncludeLinkedAccountsMetrics";
const _IM = "IncludeMetrics";
const _IR = "InsightRules";
const _K = "Key";
const _KL = "KeyLabels";
const _Ke = "Keys";
const _L = "Label";
const _LD = "ListDashboards";
const _LM = "ListMetrics";
const _LMIR = "ListManagedInsightRules";
const _LMS = "ListMetricStreams";
const _LMa = "LastModified";
const _LO = "LabelOptions";
const _LTFR = "ListTagsForResource";
const _LUD = "LastUpdateDate";
const _M = "Metrics";
const _MA = "MetricAlarms";
const _MCC = "MaxContributorCount";
const _MCV = "MaxContributorValue";
const _MD = "MaxDatapoints";
const _MDQ = "MetricDataQueries";
const _MDR = "MetricDataResults";
const _MDe = "MetricData";
const _MDet = "MetricDatapoints";
const _MMAD = "MetricMathAnomalyDetector";
const _MN = "MetricName";
const _MNe = "MetricNames";
const _MR = "MaxRecords";
const _MRa = "MaxResults";
const _MRan = "ManagedRules";
const _MRana = "ManagedRule";
const _MS = "MetricStat";
const _MT = "MetricTimezone";
const _MW = "MetricWidget";
const _MWI = "MetricWidgetImage";
const _Ma = "Maximum";
const _Me = "Metric";
const _Mes = "Message";
const _Mess = "Messages";
const _Mi = "Minimum";
const _N = "Namespace";
const _NT = "NextToken";
const _Na = "Name";
const _Nam = "Names";
const _OA = "OwningAccount";
const _OAw = "OwningAccounts";
const _OB = "OrderBy";
const _OF = "OutputFormat";
const _OKA = "OKActions";
const _P = "Period";
const _PAD = "PutAnomalyDetector";
const _PCA = "PutCompositeAlarm";
const _PD = "PutDashboard";
const _PIR = "PutInsightRule";
const _PMA = "PutMetricAlarm";
const _PMD = "PutMetricData";
const _PMIR = "PutManagedInsightRules";
const _PMS = "PutMetricStream";
const _POAN = "ParentsOfAlarmName";
const _RA = "RecentlyActive";
const _RARN = "ResourceARN";
const _RAo = "RoleArn";
const _RD = "ReturnData";
const _RDu = "RuleDefinition";
const _RI = "ResourceId";
const _RN = "RuleNames";
const _RNu = "RuleName";
const _RS = "RuleState";
const _RT = "ResourceType";
const _S = "Stat";
const _SAS = "SetAlarmState";
const _SB = "ScanBy";
const _SC = "StatisticsConfigurations";
const _SCa = "SampleCount";
const _SCt = "StatusCode";
const _SD = "StartDate";
const _SMAD = "SingleMetricAnomalyDetector";
const _SMS = "StartMetricStreams";
const _SMSt = "StopMetricStreams";
const _SR = "StorageResolution";
const _SRD = "StateReasonData";
const _SRt = "StateReason";
const _ST = "StartTime";
const _STT = "StateTransitionedTimestamp";
const _SUT = "StateUpdatedTimestamp";
const _SV = "StateValue";
const _SVt = "StatisticValues";
const _Sc = "Schema";
const _Si = "Size";
const _St = "Statistic";
const _Sta = "Statistics";
const _Stat = "State";
const _Su = "Sum";
const _T = "Timezone";
const _TK = "TagKeys";
const _TMD = "TreatMissingData";
const _TMI = "ThresholdMetricId";
const _TN = "TemplateName";
const _TR = "TagResource";
const _Ta = "Tags";
const _Th = "Threshold";
const _Ti = "Timestamp";
const _Tim = "Timestamps";
const _U = "Unit";
const _UC = "UniqueContributors";
const _UR = "UntagResource";
const _V = "Version";
const _Va = "Value";
const _Val = "Values";
const _dVM = "dashboardValidationMessages";
const _e = "entry";
const _m = "member";
const _me = "message";
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        const parser = new fxp.XMLParser({
            attributeNamePrefix: "",
            htmlEntities: true,
            ignoreAttributes: false,
            ignoreDeclaration: true,
            parseTagValue: false,
            trimValues: false,
            tagValueProcessor: (_, val) => (val.trim() === "" && val.includes("\n") ? "" : undefined),
        });
        parser.addEntity("#xD", "\r");
        parser.addEntity("#10", "\n");
        const parsedObj = parser.parse(encoded);
        const textNodeName = "#text";
        const key = Object.keys(parsedObj)[0];
        const parsedObjToReturn = parsedObj[key];
        if (parsedObjToReturn[textNodeName]) {
            parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
            delete parsedObjToReturn[textNodeName];
        }
        return (0,smithy_client_dist_es.getValueFromTextNode)(parsedObjToReturn);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    if (value.Error) {
        value.Error.message = value.Error.message ?? value.Error.Message;
    }
    return value;
};
const buildFormUrlencodedString = (formEntries) => Object.entries(formEntries)
    .map(([key, value]) => (0,smithy_client_dist_es.extendedEncodeURIComponent)(key) + "=" + (0,smithy_client_dist_es.extendedEncodeURIComponent)(value))
    .join("&");
const loadQueryErrorCode = (output, data) => {
    if (data.Error?.Code !== undefined) {
        return data.Error.Code;
    }
    if (output.statusCode == 404) {
        return "NotFound";
    }
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-cloudwatch/dist-es/commands/PutMetricDataCommand.js






class PutMetricDataCommand extends smithy_client_dist_es.Command
    .classBuilder()
    .ep({
    ...EndpointParameters.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0,middleware_serde_dist_es.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0,dist_es.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("GraniteServiceVersion20100801", "PutMetricData", {})
    .n("CloudWatchClient", "PutMetricDataCommand")
    .f(void 0, void 0)
    .ser(se_PutMetricDataCommand)
    .de(de_PutMetricDataCommand)
    .build() {
}


/***/ }),

/***/ "./node_modules/@aws-sdk/client-cloudwatch/dist-es/endpoint/EndpointParameters.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   commonParams: () => (/* binding */ commonParams),
/* harmony export */   resolveClientEndpointParameters: () => (/* binding */ resolveClientEndpointParameters)
/* harmony export */ });
const resolveClientEndpointParameters = (options) => {
    return {
        ...options,
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        defaultSigningName: "monitoring",
    };
};
const commonParams = {
    UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
    Endpoint: { type: "builtInParams", name: "endpoint" },
    Region: { type: "builtInParams", name: "region" },
    UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
};


/***/ }),

/***/ "./node_modules/@aws-sdk/client-sso/dist-es/SSOClient.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  SSOClient: () => (/* binding */ SSOClient)
});

// UNUSED EXPORTS: __Client

// EXTERNAL MODULE: ./node_modules/@aws-sdk/middleware-host-header/dist-es/index.js
var dist_es = __webpack_require__("./node_modules/@aws-sdk/middleware-host-header/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/@aws-sdk/middleware-logger/dist-es/index.js + 1 modules
var middleware_logger_dist_es = __webpack_require__("./node_modules/@aws-sdk/middleware-logger/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/@aws-sdk/middleware-recursion-detection/dist-es/index.js
var middleware_recursion_detection_dist_es = __webpack_require__("./node_modules/@aws-sdk/middleware-recursion-detection/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/@aws-sdk/middleware-user-agent/dist-es/index.js + 13 modules
var middleware_user_agent_dist_es = __webpack_require__("./node_modules/@aws-sdk/middleware-user-agent/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/@smithy/config-resolver/dist-es/index.js + 13 modules
var config_resolver_dist_es = __webpack_require__("./node_modules/@smithy/config-resolver/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/@smithy/middleware-content-length/dist-es/index.js
var middleware_content_length_dist_es = __webpack_require__("./node_modules/@smithy/middleware-content-length/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/@smithy/middleware-endpoint/dist-es/index.js + 10 modules
var middleware_endpoint_dist_es = __webpack_require__("./node_modules/@smithy/middleware-endpoint/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/@smithy/middleware-retry/dist-es/index.js + 15 modules
var middleware_retry_dist_es = __webpack_require__("./node_modules/@smithy/middleware-retry/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/@smithy/smithy-client/dist-es/index.js + 30 modules
var smithy_client_dist_es = __webpack_require__("./node_modules/@smithy/smithy-client/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-sso/dist-es/endpoint/EndpointParameters.js
var EndpointParameters = __webpack_require__("./node_modules/@aws-sdk/client-sso/dist-es/endpoint/EndpointParameters.js");
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/package.json
const package_namespaceObject = /*#__PURE__*/JSON.parse('{"version":"3.490.0"}');
// EXTERNAL MODULE: ./node_modules/@aws-sdk/core/dist-es/client/emitWarningIfUnsupportedVersion.js
var emitWarningIfUnsupportedVersion = __webpack_require__("./node_modules/@aws-sdk/core/dist-es/client/emitWarningIfUnsupportedVersion.js");
// EXTERNAL MODULE: ./node_modules/@aws-sdk/util-user-agent-node/dist-es/index.js + 2 modules
var util_user_agent_node_dist_es = __webpack_require__("./node_modules/@aws-sdk/util-user-agent-node/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/@smithy/hash-node/dist-es/index.js
var hash_node_dist_es = __webpack_require__("./node_modules/@smithy/hash-node/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/@smithy/node-config-provider/dist-es/index.js + 4 modules
var node_config_provider_dist_es = __webpack_require__("./node_modules/@smithy/node-config-provider/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/@smithy/node-http-handler/dist-es/index.js + 13 modules
var node_http_handler_dist_es = __webpack_require__("./node_modules/@smithy/node-http-handler/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/@smithy/util-body-length-node/dist-es/index.js + 1 modules
var util_body_length_node_dist_es = __webpack_require__("./node_modules/@smithy/util-body-length-node/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/@smithy/util-retry/dist-es/index.js + 8 modules
var util_retry_dist_es = __webpack_require__("./node_modules/@smithy/util-retry/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/@smithy/url-parser/dist-es/index.js + 1 modules
var url_parser_dist_es = __webpack_require__("./node_modules/@smithy/url-parser/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/@smithy/util-base64/dist-es/index.js + 2 modules
var util_base64_dist_es = __webpack_require__("./node_modules/@smithy/util-base64/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/@smithy/util-utf8/dist-es/index.js + 3 modules
var util_utf8_dist_es = __webpack_require__("./node_modules/@smithy/util-utf8/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/@smithy/util-endpoints/dist-es/index.js + 34 modules
var util_endpoints_dist_es = __webpack_require__("./node_modules/@smithy/util-endpoints/dist-es/index.js");
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/dist-es/endpoint/ruleset.js
const u = "required", v = "fn", w = "argv", x = "ref";
const a = true, b = "isSet", c = "booleanEquals", d = "error", e = "endpoint", f = "tree", g = "PartitionResult", h = "getAttr", i = { [u]: false, "type": "String" }, j = { [u]: true, "default": false, "type": "Boolean" }, k = { [x]: "Endpoint" }, l = { [v]: c, [w]: [{ [x]: "UseFIPS" }, true] }, m = { [v]: c, [w]: [{ [x]: "UseDualStack" }, true] }, n = {}, o = { [v]: h, [w]: [{ [x]: g }, "supportsFIPS"] }, p = { [x]: g }, q = { [v]: c, [w]: [true, { [v]: h, [w]: [p, "supportsDualStack"] }] }, r = [l], s = [m], t = [{ [x]: "Region" }];
const _data = { version: "1.0", parameters: { Region: i, UseDualStack: j, UseFIPS: j, Endpoint: i }, rules: [{ conditions: [{ [v]: b, [w]: [k] }], rules: [{ conditions: r, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: d }, { conditions: s, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: d }, { endpoint: { url: k, properties: n, headers: n }, type: e }], type: f }, { conditions: [{ [v]: b, [w]: t }], rules: [{ conditions: [{ [v]: "aws.partition", [w]: t, assign: g }], rules: [{ conditions: [l, m], rules: [{ conditions: [{ [v]: c, [w]: [a, o] }, q], rules: [{ endpoint: { url: "https://portal.sso-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: n, headers: n }, type: e }], type: f }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: d }], type: f }, { conditions: r, rules: [{ conditions: [{ [v]: c, [w]: [o, a] }], rules: [{ conditions: [{ [v]: "stringEquals", [w]: [{ [v]: h, [w]: [p, "name"] }, "aws-us-gov"] }], endpoint: { url: "https://portal.sso.{Region}.amazonaws.com", properties: n, headers: n }, type: e }, { endpoint: { url: "https://portal.sso-fips.{Region}.{PartitionResult#dnsSuffix}", properties: n, headers: n }, type: e }], type: f }, { error: "FIPS is enabled but this partition does not support FIPS", type: d }], type: f }, { conditions: s, rules: [{ conditions: [q], rules: [{ endpoint: { url: "https://portal.sso.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: n, headers: n }, type: e }], type: f }, { error: "DualStack is enabled but this partition does not support DualStack", type: d }], type: f }, { endpoint: { url: "https://portal.sso.{Region}.{PartitionResult#dnsSuffix}", properties: n, headers: n }, type: e }], type: f }], type: f }, { error: "Invalid Configuration: Missing Region", type: d }] };
const ruleSet = _data;

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/dist-es/endpoint/endpointResolver.js


const defaultEndpointResolver = (endpointParams, context = {}) => {
    return (0,util_endpoints_dist_es.resolveEndpoint)(ruleSet, {
        endpointParams: endpointParams,
        logger: context.logger,
    });
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/dist-es/runtimeConfig.shared.js





const getRuntimeConfig = (config) => {
    return {
        apiVersion: "2019-06-10",
        base64Decoder: config?.base64Decoder ?? util_base64_dist_es.fromBase64,
        base64Encoder: config?.base64Encoder ?? util_base64_dist_es.toBase64,
        disableHostPrefix: config?.disableHostPrefix ?? false,
        endpointProvider: config?.endpointProvider ?? defaultEndpointResolver,
        extensions: config?.extensions ?? [],
        logger: config?.logger ?? new smithy_client_dist_es.NoOpLogger(),
        serviceId: config?.serviceId ?? "SSO",
        urlParser: config?.urlParser ?? url_parser_dist_es.parseUrl,
        utf8Decoder: config?.utf8Decoder ?? util_utf8_dist_es.fromUtf8,
        utf8Encoder: config?.utf8Encoder ?? util_utf8_dist_es.toUtf8,
    };
};

// EXTERNAL MODULE: ./node_modules/@smithy/util-defaults-mode-node/dist-es/index.js + 3 modules
var util_defaults_mode_node_dist_es = __webpack_require__("./node_modules/@smithy/util-defaults-mode-node/dist-es/index.js");
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/dist-es/runtimeConfig.js














const runtimeConfig_getRuntimeConfig = (config) => {
    (0,smithy_client_dist_es.emitWarningIfUnsupportedVersion)(process.version);
    const defaultsMode = (0,util_defaults_mode_node_dist_es.resolveDefaultsModeConfig)(config);
    const defaultConfigProvider = () => defaultsMode().then(smithy_client_dist_es.loadConfigsForDefaultMode);
    const clientSharedValues = getRuntimeConfig(config);
    (0,emitWarningIfUnsupportedVersion.emitWarningIfUnsupportedVersion)(process.version);
    return {
        ...clientSharedValues,
        ...config,
        runtime: "node",
        defaultsMode,
        bodyLengthChecker: config?.bodyLengthChecker ?? util_body_length_node_dist_es.calculateBodyLength,
        defaultUserAgentProvider: config?.defaultUserAgentProvider ??
            (0,util_user_agent_node_dist_es.defaultUserAgent)({ serviceId: clientSharedValues.serviceId, clientVersion: package_namespaceObject.version }),
        maxAttempts: config?.maxAttempts ?? (0,node_config_provider_dist_es.loadConfig)(middleware_retry_dist_es.NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
        region: config?.region ?? (0,node_config_provider_dist_es.loadConfig)(config_resolver_dist_es.NODE_REGION_CONFIG_OPTIONS, config_resolver_dist_es.NODE_REGION_CONFIG_FILE_OPTIONS),
        requestHandler: config?.requestHandler ?? new node_http_handler_dist_es.NodeHttpHandler(defaultConfigProvider),
        retryMode: config?.retryMode ??
            (0,node_config_provider_dist_es.loadConfig)({
                ...middleware_retry_dist_es.NODE_RETRY_MODE_CONFIG_OPTIONS,
                default: async () => (await defaultConfigProvider()).retryMode || util_retry_dist_es.DEFAULT_RETRY_MODE,
            }),
        sha256: config?.sha256 ?? hash_node_dist_es.Hash.bind(null, "sha256"),
        streamCollector: config?.streamCollector ?? node_http_handler_dist_es.streamCollector,
        useDualstackEndpoint: config?.useDualstackEndpoint ?? (0,node_config_provider_dist_es.loadConfig)(config_resolver_dist_es.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
        useFipsEndpoint: config?.useFipsEndpoint ?? (0,node_config_provider_dist_es.loadConfig)(config_resolver_dist_es.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS),
    };
};

// EXTERNAL MODULE: ./node_modules/@aws-sdk/region-config-resolver/dist-es/index.js + 3 modules
var region_config_resolver_dist_es = __webpack_require__("./node_modules/@aws-sdk/region-config-resolver/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/@smithy/protocol-http/dist-es/index.js + 5 modules
var protocol_http_dist_es = __webpack_require__("./node_modules/@smithy/protocol-http/dist-es/index.js");
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/dist-es/runtimeExtensions.js



const asPartial = (t) => t;
const resolveRuntimeExtensions = (runtimeConfig, extensions) => {
    const extensionConfiguration = {
        ...asPartial((0,region_config_resolver_dist_es.getAwsRegionExtensionConfiguration)(runtimeConfig)),
        ...asPartial((0,smithy_client_dist_es.getDefaultExtensionConfiguration)(runtimeConfig)),
        ...asPartial((0,protocol_http_dist_es.getHttpHandlerExtensionConfiguration)(runtimeConfig)),
    };
    extensions.forEach((extension) => extension.configure(extensionConfiguration));
    return {
        ...runtimeConfig,
        ...(0,region_config_resolver_dist_es.resolveAwsRegionExtensionConfiguration)(extensionConfiguration),
        ...(0,smithy_client_dist_es.resolveDefaultRuntimeConfig)(extensionConfiguration),
        ...(0,protocol_http_dist_es.resolveHttpHandlerRuntimeConfig)(extensionConfiguration),
    };
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/dist-es/SSOClient.js













class SSOClient extends smithy_client_dist_es.Client {
    constructor(...[configuration]) {
        const _config_0 = runtimeConfig_getRuntimeConfig(configuration || {});
        const _config_1 = (0,EndpointParameters.resolveClientEndpointParameters)(_config_0);
        const _config_2 = (0,config_resolver_dist_es.resolveRegionConfig)(_config_1);
        const _config_3 = (0,middleware_endpoint_dist_es.resolveEndpointConfig)(_config_2);
        const _config_4 = (0,middleware_retry_dist_es.resolveRetryConfig)(_config_3);
        const _config_5 = (0,dist_es.resolveHostHeaderConfig)(_config_4);
        const _config_6 = (0,middleware_user_agent_dist_es.resolveUserAgentConfig)(_config_5);
        const _config_7 = resolveRuntimeExtensions(_config_6, configuration?.extensions || []);
        super(_config_7);
        this.config = _config_7;
        this.middlewareStack.use((0,middleware_retry_dist_es.getRetryPlugin)(this.config));
        this.middlewareStack.use((0,middleware_content_length_dist_es.getContentLengthPlugin)(this.config));
        this.middlewareStack.use((0,dist_es.getHostHeaderPlugin)(this.config));
        this.middlewareStack.use((0,middleware_logger_dist_es.getLoggerPlugin)(this.config));
        this.middlewareStack.use((0,middleware_recursion_detection_dist_es.getRecursionDetectionPlugin)(this.config));
        this.middlewareStack.use((0,middleware_user_agent_dist_es.getUserAgentPlugin)(this.config));
    }
    destroy() {
        super.destroy();
    }
}


/***/ }),

/***/ "./node_modules/@aws-sdk/client-sso/dist-es/commands/GetRoleCredentialsCommand.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  GetRoleCredentialsCommand: () => (/* binding */ GetRoleCredentialsCommand)
});

// UNUSED EXPORTS: $Command

// EXTERNAL MODULE: ./node_modules/@smithy/middleware-endpoint/dist-es/index.js + 10 modules
var dist_es = __webpack_require__("./node_modules/@smithy/middleware-endpoint/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/@smithy/middleware-serde/dist-es/index.js + 3 modules
var middleware_serde_dist_es = __webpack_require__("./node_modules/@smithy/middleware-serde/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/@smithy/smithy-client/dist-es/index.js + 30 modules
var smithy_client_dist_es = __webpack_require__("./node_modules/@smithy/smithy-client/dist-es/index.js");
// EXTERNAL MODULE: ./node_modules/@aws-sdk/client-sso/dist-es/endpoint/EndpointParameters.js
var EndpointParameters = __webpack_require__("./node_modules/@aws-sdk/client-sso/dist-es/endpoint/EndpointParameters.js");
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/dist-es/models/SSOServiceException.js


class SSOServiceException extends smithy_client_dist_es.ServiceException {
    constructor(options) {
        super(options);
        Object.setPrototypeOf(this, SSOServiceException.prototype);
    }
}

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/dist-es/models/models_0.js


class InvalidRequestException extends SSOServiceException {
    constructor(opts) {
        super({
            name: "InvalidRequestException",
            $fault: "client",
            ...opts,
        });
        this.name = "InvalidRequestException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidRequestException.prototype);
    }
}
class ResourceNotFoundException extends SSOServiceException {
    constructor(opts) {
        super({
            name: "ResourceNotFoundException",
            $fault: "client",
            ...opts,
        });
        this.name = "ResourceNotFoundException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ResourceNotFoundException.prototype);
    }
}
class TooManyRequestsException extends SSOServiceException {
    constructor(opts) {
        super({
            name: "TooManyRequestsException",
            $fault: "client",
            ...opts,
        });
        this.name = "TooManyRequestsException";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyRequestsException.prototype);
    }
}
class UnauthorizedException extends SSOServiceException {
    constructor(opts) {
        super({
            name: "UnauthorizedException",
            $fault: "client",
            ...opts,
        });
        this.name = "UnauthorizedException";
        this.$fault = "client";
        Object.setPrototypeOf(this, UnauthorizedException.prototype);
    }
}
const GetRoleCredentialsRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.accessToken && { accessToken: smithy_client_dist_es.SENSITIVE_STRING }),
});
const RoleCredentialsFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.secretAccessKey && { secretAccessKey: smithy_client_dist_es.SENSITIVE_STRING }),
    ...(obj.sessionToken && { sessionToken: smithy_client_dist_es.SENSITIVE_STRING }),
});
const GetRoleCredentialsResponseFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.roleCredentials && { roleCredentials: RoleCredentialsFilterSensitiveLog(obj.roleCredentials) }),
});
const ListAccountRolesRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.accessToken && { accessToken: SENSITIVE_STRING }),
});
const ListAccountsRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.accessToken && { accessToken: SENSITIVE_STRING }),
});
const LogoutRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.accessToken && { accessToken: SENSITIVE_STRING }),
});

// EXTERNAL MODULE: ./node_modules/@smithy/core/dist-es/index.js + 16 modules
var core_dist_es = __webpack_require__("./node_modules/@smithy/core/dist-es/index.js");
;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/dist-es/protocols/Aws_restJson1.js




const se_GetRoleCredentialsCommand = async (input, context) => {
    const b = (0,core_dist_es.requestBuilder)(input, context);
    const headers = (0,smithy_client_dist_es.map)({}, isSerializableHeaderValue, {
        [_xasbt]: input[_aT],
    });
    b.bp("/federation/credentials");
    const query = (0,smithy_client_dist_es.map)({
        [_rn]: [, (0,smithy_client_dist_es.expectNonNull)(input[_rN], `roleName`)],
        [_ai]: [, (0,smithy_client_dist_es.expectNonNull)(input[_aI], `accountId`)],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
const se_ListAccountRolesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_xasbt]: input[_aT],
    });
    b.bp("/assignment/roles");
    const query = map({
        [_nt]: [, input[_nT]],
        [_mr]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_ai]: [, __expectNonNull(input[_aI], `accountId`)],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
const se_ListAccountsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_xasbt]: input[_aT],
    });
    b.bp("/assignment/accounts");
    const query = map({
        [_nt]: [, input[_nT]],
        [_mr]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
const se_LogoutCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_xasbt]: input[_aT],
    });
    b.bp("/logout");
    let body;
    b.m("POST").h(headers).b(body);
    return b.build();
};
const de_GetRoleCredentialsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetRoleCredentialsCommandError(output, context);
    }
    const contents = (0,smithy_client_dist_es.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0,smithy_client_dist_es.expectNonNull)((0,smithy_client_dist_es.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0,smithy_client_dist_es.take)(data, {
        roleCredentials: smithy_client_dist_es._json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetRoleCredentialsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.sso#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.sso#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.sso#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.sso#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListAccountRolesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListAccountRolesCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        roleList: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListAccountRolesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.sso#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.sso#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.sso#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.sso#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListAccountsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListAccountsCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        accountList: _json,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListAccountsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.sso#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.sso#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.sso#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.sso#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_LogoutCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_LogoutCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_LogoutCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.sso#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.sso#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.sso#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const throwDefaultError = (0,smithy_client_dist_es.withBaseException)(SSOServiceException);
const de_InvalidRequestExceptionRes = async (parsedOutput, context) => {
    const contents = (0,smithy_client_dist_es.map)({});
    const data = parsedOutput.body;
    const doc = (0,smithy_client_dist_es.take)(data, {
        message: smithy_client_dist_es.expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidRequestException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0,smithy_client_dist_es.decorateServiceException)(exception, parsedOutput.body);
};
const de_ResourceNotFoundExceptionRes = async (parsedOutput, context) => {
    const contents = (0,smithy_client_dist_es.map)({});
    const data = parsedOutput.body;
    const doc = (0,smithy_client_dist_es.take)(data, {
        message: smithy_client_dist_es.expectString,
    });
    Object.assign(contents, doc);
    const exception = new ResourceNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0,smithy_client_dist_es.decorateServiceException)(exception, parsedOutput.body);
};
const de_TooManyRequestsExceptionRes = async (parsedOutput, context) => {
    const contents = (0,smithy_client_dist_es.map)({});
    const data = parsedOutput.body;
    const doc = (0,smithy_client_dist_es.take)(data, {
        message: smithy_client_dist_es.expectString,
    });
    Object.assign(contents, doc);
    const exception = new TooManyRequestsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0,smithy_client_dist_es.decorateServiceException)(exception, parsedOutput.body);
};
const de_UnauthorizedExceptionRes = async (parsedOutput, context) => {
    const contents = (0,smithy_client_dist_es.map)({});
    const data = parsedOutput.body;
    const doc = (0,smithy_client_dist_es.take)(data, {
        message: smithy_client_dist_es.expectString,
    });
    Object.assign(contents, doc);
    const exception = new UnauthorizedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0,smithy_client_dist_es.decorateServiceException)(exception, parsedOutput.body);
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => (0,smithy_client_dist_es.collectBody)(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const _aI = "accountId";
const _aT = "accessToken";
const _ai = "account_id";
const _mR = "maxResults";
const _mr = "max_result";
const _nT = "nextToken";
const _nt = "next_token";
const _rN = "roleName";
const _rn = "role_name";
const _xasbt = "x-amz-sso_bearer_token";
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};

;// CONCATENATED MODULE: ./node_modules/@aws-sdk/client-sso/dist-es/commands/GetRoleCredentialsCommand.js







class GetRoleCredentialsCommand extends smithy_client_dist_es.Command
    .classBuilder()
    .ep({
    ...EndpointParameters.commonParams,
})
    .m(function (Command, cs, config, o) {
    return [
        (0,middleware_serde_dist_es.getSerdePlugin)(config, this.serialize, this.deserialize),
        (0,dist_es.getEndpointPlugin)(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("SWBPortalService", "GetRoleCredentials", {})
    .n("SSOClient", "GetRoleCredentialsCommand")
    .f(GetRoleCredentialsRequestFilterSensitiveLog, GetRoleCredentialsResponseFilterSensitiveLog)
    .ser(se_GetRoleCredentialsCommand)
    .de(de_GetRoleCredentialsCommand)
    .build() {
}


/***/ }),

/***/ "./node_modules/@aws-sdk/client-sso/dist-es/endpoint/EndpointParameters.js":
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   commonParams: () => (/* binding */ commonParams),
/* harmony export */   resolveClientEndpointParameters: () => (/* binding */ resolveClientEndpointParameters)
/* harmony export */ });
const resolveClientEndpointParameters = (options) => {
    return {
        ...options,
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        defaultSigningName: "awsssoportal",
    };
};
const commonParams = {
    UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
    Endpoint: { type: "builtInParams", name: "endpoint" },
    Region: { type: "builtInParams", name: "region" },
    UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
};


/***/ })

};
;